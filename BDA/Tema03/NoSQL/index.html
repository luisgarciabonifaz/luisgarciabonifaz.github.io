
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.3.1">
    
    
      
        <title>NoSQL - Mis Clases</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.046329b4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bases-de-datos-nosql" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Mis Clases" class="md-header__button md-logo" aria-label="Mis Clases" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mis Clases
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              NoSQL
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Mis Clases" class="md-nav__button md-logo" aria-label="Mis Clases" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Mis Clases
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Inicio
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sistemes Operatius Monolloc
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Sistemes Operatius Monolloc
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema01/SistemesInformatics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Sistemes Informàtics
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema02/SistemesOperatius/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T2 - Sistemes Operatius
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema03/GestioRecursos/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T3 - Gestio de Recursos
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sistemas Big Data
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Sistemas Big Data
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SBD/Tema01/BigDataConAWS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Big Data con AWS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SBD/Tema01/PracticasAWS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T12 - AWS
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Big Data Aplicado
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Big Data Aplicado
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Tema01/IntroduccionBigData/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Introducción Big Data
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Tema02/RepasoSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T2 - Repaso SQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#que-son-las-bases-de-datos-nosql" class="md-nav__link">
    ¿Qué son las bases de datos NoSQL?
  </a>
  
    <nav class="md-nav" aria-label="¿Qué son las bases de datos NoSQL?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#caracteristicas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Características de las bases de datos NoSQL:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ventajas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Ventajas de las bases de datos NoSQL:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#desventajas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Desventajas de las bases de datos NoSQL:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tipos-de-bases-de-datos-nosql" class="md-nav__link">
    Tipos de bases de datos NoSQL:
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>= 3. No 
== 3.1. Bases de datos No SQL </p>
<h1 id="bases-de-datos-nosql">Bases de Datos NoSQL</h1>
<h2 id="que-son-las-bases-de-datos-nosql">¿Qué son las bases de datos NoSQL?</h2>
<p>Las bases de datos NoSQL (NoSQL significa "Not Only SQL" o "No Solo SQL") son sistemas de gestión de bases de datos diseñados para manejar tipos de datos y escenarios de aplicación que no se ajustan bien a las bases de datos relacionales tradicionales. </p>
<p>A diferencia de las bases de datos SQL, que utilizan un esquema fijo y tablas para almacenar datos, las bases de datos NoSQL utilizan diferentes modelos de datos y estructuras de almacenamiento flexibles.</p>
<h3 id="caracteristicas-de-las-bases-de-datos-nosql">Características de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Esquema flexible:</strong> NoSQL permite almacenar datos sin necesidad de un esquema predefinido.</p>
</li>
<li>
<p><strong>Escalabilidad horizontal:</strong> Las bases de datos NoSQL están diseñadas para escalar horizontalmente.</p>
</li>
<li>
<p><strong>Modelos de datos variados:</strong> Existen varios tipos de bases de datos NoSQL, incluyendo bases de datos de documentos, bases de datos de columnas, bases de datos clave-valor y bases de datos de grafos.</p>
</li>
<li>
<p><strong>Alta disponibilidad:</strong> Las bases de datos NoSQL suelen garantizar la disponibilidad continua de los datos.</p>
</li>
</ul>
<h3 id="ventajas-de-las-bases-de-datos-nosql">Ventajas de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Escalabilidad:</strong> Son ideales para aplicaciones web y móviles que requieren escalabilidad rápida y eficiente.</p>
</li>
<li>
<p><strong>Flexibilidad:</strong> Pueden manejar datos no estructurados o semiestructurados.</p>
</li>
<li>
<p><strong>Rendimiento:</strong> Ofrecen un rendimiento más rápido para ciertos tipos de consultas.</p>
</li>
</ul>
<h3 id="desventajas-de-las-bases-de-datos-nosql">Desventajas de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Falta de estándares:</strong> La diversidad de modelos y sistemas NoSQL dificulta la elección y la migración entre sistemas.</p>
</li>
<li>
<p><strong>Menos soporte para consultas complejas:</strong> No son ideales para aplicaciones que requieren operaciones complejas de tipo JOIN y agregación.</p>
</li>
</ul>
<h2 id="tipos-de-bases-de-datos-nosql">Tipos de bases de datos NoSQL:</h2>
<ul>
<li>
<p><strong>Bases de datos de documentos:</strong></p>
</li>
<li>
<p><strong>Explicación:</strong> Almacenan datos en formato de documentos semiestructurados, como JSON o XML.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://www.mongodb.com/">MongoDB</a></li>
<li><a href="https://www.couchbase.com/">Couchbase</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos de columnas:</strong></p>
</li>
<li>
<p><strong>Explicación:</strong> Almacenan datos en columnas en lugar de filas.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://cassandra.apache.org/">Apache Cassandra</a></li>
<li><a href="https://hbase.apache.org/">HBase</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos clave-valor:</strong></p>
</li>
<li>
<p><strong>Explicación:</strong> Almacenan datos como pares de clave y valor.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://redis.io/">Redis</a></li>
<li><a href="http://docs.basho.com/riak/kv/latest/">Riak</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos de grafos:</strong></p>
</li>
<li>
<p><strong>Explicación:</strong> Almacenan datos como nodos y relaciones.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://neo4j.com/">Neo4j</a></li>
<li><a href="https://aws.amazon.com/neptune/">Amazon Neptune</a></li>
</ul>
</li>
</ul>
<p>Recuerda que cada tipo de base de datos NoSQL tiene sus propias características y casos de uso específicos. La elección dependerá de las necesidades de tu proyecto.</p>
<p>== 3.2. MongoDB 
=== 3.2.1. Conceptos Básicos 
Los elementos de MongoDB son:
  * <strong>Bases de Datos</strong>:
    * Actúa cada una como un contenedor de alto nivel
  * <strong>Colecciones</strong>:
    * Una base de datos tendrá 0 o más colecciones. 
    * Una colección es muy similar a lo que entendemos como tabla dentro de un SGDB.
  * <strong>Documentos</strong>:
    * Las colecciones contiene 0 o más documentos, por lo que es similar a una fila o registro de un RDMS.</p>
<p>==== 3.2.1.1. Documentos</p>
<p>El corazón de MongoDB es el documento, un conjunto ordenado de claves con valores asociados. Su representación como hemos nombrado en el tema anterior es en JSON, un formato muy intuitivo y que no pensamos que requiera mayor explicación. Este podría ser un ejemplo sencillo de un documento que guarda el nombre, apellidos y dedad de una persona. A la izquierda de los dos puntos el nombre del campo y a la derecha el valor.
'''json
  {
  nombre:”Jose Antonio”,
  apellidos:”Guillem Benedito”,
  edad:35
  }
'''
Las claves de los documentos:
  * No pueden ser nulas.
  * No pueden contener los caracteres . (punto) y $ (dólar).
  * Puede contener cualquiera de los demás caracteres UTF-8 existentes.
  * Son case-sensitive (sensible a mayúsculas y minúsculas), por lo que las claves “nombre” y “Nombre” son diferentes, y por tanto consideradas como campos diferentes.
  * Las claves dentro de un mismo documento deben ser únicas, no pueden duplicarse. Así por ejemplo el siguiente documento no es válido por tener dos veces la clave nota.</p>
<p>'''jon
  {
  nombre:”Jose Antonio”,
  nota:8.9,
  nota:7.2 
  }
  '''</p>
<p>Cada documento en Mongo debe tener <strong>obligatoriamente</strong> un campo _id con valor único y que actuará como identificador único del documento. Es tan necesario este campo que cuando se guarda un documento sin especificarlo, Mongo automáticamente le asigna uno del tipo ObjectId.</p>
<p>==== 3.2.1.2. Colecciones </p>
<p>Una colección es un grupo de documentos, es lo análogo a las tablas en el modelo relacional.
Las colecciones tienen esquemas dinámicos, lo que significa que los documentos dentro de una colección pueden tener múltiples “formas”. Por ejemplo, los siguientes documentos podrían guardarse en la misma colección, a pesar de tener diferentes campos, y diferentes tipos de dato.</p>
<p active:true="active:true" type:6_="type:6," username::_pepito_="username::”pepito”,">{ nombre:”Jose Antonio”, edad:35 }</p>
<p>Hay algunas restricciones respecto a nombre que una colección puede tener:
  * La cadena vacía (“”) no es un nombre válido.
  * Lo puede contener el carácter null.
  * No se pueden crear colecciones cuyo nombre empiece por “system.”, ya que es un prefijo reservado para colecciones internas.
  * No debe contener el carácter $ (dólar).</p>
<p>=== 3.2.2. Operaciones básicas
==== 3.2.2.1. Inserción ===</p>
<p>Para insertar un documento en una colección, utilice el método:
  db.alumno.insert( {"name":"Antonio Cuenca"})</p>
<p>El comando ha añadido automáticamente el campo _id de tipo ObjectId, ya que como hemos explicado, todo documento debe tener un identificador único.
Pero el uso del tipo ObjectId para el campo _id no es obligatorio, podemos utilizar cualquier valor, siempre y cuando garanticemos su unicidad. A continuación insertamos una nueva alumna, especificando que su _id es el número 10 (tipo Long).
  db.alumno.insert( { _id:NumberLong(10), name:"Raquel",apellidos:"Gutierrez Garcia"} )</p>
<p>Si queremos insertar múltiples documentos,podemos hacer la inserción más rápida utilizando batch inserts, que permiten insertar en bloque un array de documentos a la colección. Esto se consigue con solo pasar un array de objetos al comando insert.
  db.numerosprimos.insert(
  [{_id:2},{_id:3},{_id:5},{_id:7},{_id:11},{_id:13},{_id:17},{_id:19},
  {_id:23}] )</p>
<p>==== 3.2.2.2. Borrado 
Vaya con cuidado, eliminar colecciones completas es muy sencillo en Mongo. Esto borrará todo, tanto la colección como meta propiedades asociadas a ella o
índices creados sobre campos.
  db.alumno.drop()
Por otra parte, para eliminar solo documentos de una colección, tenemos el comando remove, que recibe como parámetro el criterio de borrado en forma de documento JSON. En ese caso, solo los documentos que cumplen el criterio se eliminarán de la colección.
  db.numerosprimos.remove( {_id:23} )</p>
<p>==== 3.2.2.3. Modificación 
Para modificar un documento se utiliza el método update. Este método recibe dos parámetros, el primero es el criterio de actualización, y el segundo el modificador, que describe los cambios que deben realizarse.</p>
<p>Tenemos dos tipos de actualización. El cambio completo del documento o reemplazo y la modificación de algunos elementos del documento</p>
<p>Veamos un ejemplo de reemplazo. Creamos un elemento con los siguientes datos:<br />
  db.usuarios.insert({name:"jose",friends:32,enemies:2})</p>
<p>El documento seria:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "friends" : 32,
    "enemies" : 2
  }  </p>
<p>Ahora lo reemplazamos:
  db.usuarios.update( {name:"jose"}, {name:"jose",relationships: {friends:32,enemies:2}})</p>
<p>Y quedaría así:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "relationships" : {
       "friends" : 32,
       "enemies" : 2
    }
  }</p>
<p>Si lo que queremos es modificar algunos campos utilizaremos el insert, pero con modificadores. Veámoslos:</p>
<p><strong>$set</strong></p>
<p>Asigna el valor a un campo. Si el campo todavía no existe en el documento lo creará. Se utiliza en el segundo parámetro que se le pasa al comando update.
  db.alumno.insert( { name:"Arturo", apellidos:"Leon Zapata" })
  db.alumno.update( {name:"Arturo"}, { $set: {edad:17} })</p>
<p>Podemos darle valor a varios campos a la vez, simplemente informando los pares clave:valor separados por coma. En este ejemplo damos valor a tres campos diferentes con un solo comando.
  db.alumno.update( {name:"Arturo"}, { $set:{nota:8.2,orden:12,actitud:"positiva"} })</p>
<p><strong>$unset</strong></p>
<p>Para eliminar cualquier campo de uno o varios documentos lo hacemos también con el comando update pero con el modificador $unset.
En MongoDB es habitual utilizar los valores 1 y -1 para indicar verdadero y falso respectivamente. En este caso, al especificar valor 1 estamos diciendo que la
clave entra dentro del conjunto de campos en los que queremos aplicar el $unset.
De esta forma, si queremos eliminar el campo “edad” del documento que guarda la información del alumno “Arturo”, lo haríamos así.
  db.alumno.update({name:"Arturo"},{$unset:{edad:1}})</p>
<p><strong>$inc</strong></p>
<p>Este modificador puede utilizarse para incrementar o decrementar el valor numérico de una clave existente o para crear una nueva si no existe.
  db.alumno.update({name:"Arturo"},{$inc:{puntuacion:2}})</p>
<p>Otros operadores que podemos utilizar de forma similar son <strong>$mul, $min, $max y $currentDate</strong>.
  db.alumno.update({name:"Arturo"},{$min:{puntuacion:3}})
El ejmplo de arriba modifica la puntuacion si esta es menor que3</p>
<p>Ahora vamos a ver modificadores de arrays.
<strong>$push</strong>
Se utiliza para añadir elementos a un array. Si el array no existe lo crea con los elementos indicados en el push, y si ya existe los añade al final del array.
  db.alumno.insert({name:"Sofia", apellidos:"Alarcon Sevilla"})
  db.alumno.update({name:"Sofia"},{$push:{"asignaturas":{name:"Matematicas", nota:9.1}}})</p>
<p><strong>$pull</strong></p>
<p>Hay varias formas de eliminar elementos de un array. Cuando queremos borrar elementos basados en algún criterio, el modificador adecuado es $pull.
Partimos de un array y borraremos elementos
  db.lists.insert({"todo": ["lavar platos", "colada", "tender"]})
Para eliminar la colada haríamos.
  db.lists.update({},{$pull:{"todo":"colada"}})</p>
<p><strong>$pop</strong></p>
<p>Para eliminar el primer o último elemento del array.
Para eliminar el último elemento del array:
  db.lists.update({},{$pop:{todo:1}})
Para eliminar el prtimer elemento del array:
  db.lists.update({},{$pop:{todo:-1}})</p>
<p><strong>Upserts</strong></p>
<p>Un upsert es un tipo de update espcial. Si no se encuentra ningún documento que haga matching con el criterio del update, entonces se creará un nuevo documento combinando el criterio y lo que se quiere actualizar. Si se encuentra un documento que haga matching se actualizará normalmente.
Para decirle a MongoDB que queremos hacer un upsert, solo hay que pasar al comando update un tercer parámetro, con valor true. Esto significa que el update se comportará como hemos explicado que lo hace el upsert. 
  update({...},{...},true)
  db.alumno.update({name:"Sofia"},{$set:{apellidos:"Alarcon Revilla"}},true)</p>
<p><strong>Multiples Documentos</strong></p>
<p>Para modificar múltiples documentos, en el tercer parámetro del update indicaremos {multi: true}. 
  db.books.update({lang:"en"},{$inc: {price: 50.00}}, {multi:true})</p>
<p>==== Consultas ====
El método find es el que se utiliza para hacer queries en Mongo. Es el equivalente al comando select en el modelo relacional. Al consultar una colección, Mongo nos
devolverá un subconjunto de documentos, que variará desde el conjunto vació hasta la colección completa.
Find tiene varios parámetros de entrada, el primero de ellos especifica los documentos que queremos recuperar, esto es, el criterio de búsqueda.
  db.coleccion1.find({ clave1:valor1 })
La función anterior nos devolvería documentos de la colección coleccion1 cuyo campo clave1 tenga un valor igual a valor1.</p>
<p>El valor por defecto para este primer parámetro es {}, que significa “cualquier documento”. Por tanto una query como db.coleccion1.find({ }) devolverá todos los documentos de la colección coleccion1. Como es el valor por defecto para el criterio de la consulta es equivalente hacer find({ }) y find( ).</p>
<p>db.alumno.find({edad:17})
  db.alumno.find({name:"Antonio"})</p>
<p>Igual que en SQL podemos especificar los campos que queremos recuperar (select campo1, campo2, campo3 from tabla ... ), podemos hacerlo también en Mongo. Para ello solo tenemos que pasar un segundo parámetro al método find, en el que decimos los que queremos.
  db.coleccion1.find({ },{ clave3:1, clave4:1 })
Los campos que queremos que sean d====== 2. No SQL ======
===== Bases de datos No SQL =====
===== MongoDB =====
==== Conceptos Básicos ====
Los elementos de MongoDB son:
  * <strong>Bases de Datos</strong>:
    * Actúa cada una como un contenedor de alto nivel
  * <strong>Colecciones</strong>:
    * Una base de datos tendrá 0 o más colecciones. 
    * Una colección es muy similar a lo que entendemos como tabla dentro de un SGDB.
  * <strong>Documentos</strong>:
    * Las colecciones contiene 0 o más documentos, por lo que es similar a una fila o registro de un RDMS.</p>
<p>=== Documentos ===</p>
<p>El corazón de MongoDB es el documento, un conjunto ordenado de claves con valores asociados. Su representación como hemos nombrado en el tema anterior es en JSON, un formato muy intuitivo y que no pensamos que requiera mayor explicación. Este podría ser un ejemplo sencillo de un documento que guarda el nombre, apellidos y dedad de una persona. A la izquierda de los dos puntos el nombre del campo y a la derecha el valor.</p>
<p>{
  nombre:”Jose Antonio”,
  apellidos:”Guillem Benedito”,
  edad:35
  }</p>
<p>Las claves de los documentos:
  * No pueden ser nulas.
  * No pueden contener los caracteres . (punto) y $ (dólar).
  * Puede contener cualquiera de los demás caracteres UTF-8 existentes.
  * Son case-sensitive (sensible a mayúsculas y minúsculas), por lo que las claves “nombre” y “Nombre” son diferentes, y por tanto consideradas como campos diferentes.
  * Las claves dentro de un mismo documento deben ser únicas, no pueden duplicarse. Así por ejemplo el siguiente documento no es válido por tener dos veces la clave nota.</p>
<p>'''json
  {
  nombre:”Jose Antonio”,
  nota:8.9,
  nota:7.2 
  }
  '''</p>
<p>Cada documento en Mongo debe tener <strong>obligatoriamente</strong> un campo _id con valor único y que actuará como identificador único del documento. Es tan necesario este campo que cuando se guarda un documento sin especificarlo, Mongo automáticamente le asigna uno del tipo ObjectId.</p>
<p>=== Colecciones ===</p>
<p>Una colección es un grupo de documentos, es lo análogo a las tablas en el modelo relacional.
Las colecciones tienen esquemas dinámicos, lo que significa que los documentos dentro de una colección pueden tener múltiples “formas”. Por ejemplo, los siguientes documentos podrían guardarse en la misma colección, a pesar de tener diferentes campos, y diferentes tipos de dato.</p>
<p active:true="active:true" type:6_="type:6," username::_pepito_="username::”pepito”,">{ nombre:”Jose Antonio”, edad:35 }</p>
<p>Hay algunas restricciones respecto a nombre que una colección puede tener:
  * La cadena vacía (“”) no es un nombre válido.
  * Lo puede contener el carácter null.
  * No se pueden crear colecciones cuyo nombre empiece por “system.”, ya que es un prefijo reservado para colecciones internas.
  * No debe contener el carácter $ (dólar).</p>
<p>==== Operaciones básicas ====
=== Inserción ===</p>
<p>Para insertar un documento en una colección, utilice el método:
  db.alumno.insert( {"name":"Antonio Cuenca"})</p>
<p>El comando ha añadido automáticamente el campo _id de tipo ObjectId, ya que como hemos explicado, todo documento debe tener un identificador único.
Pero el uso del tipo ObjectId para el campo _id no es obligatorio, podemos utilizar cualquier valor, siempre y cuando garanticemos su unicidad. A continuación insertamos una nueva alumna, especificando que su _id es el número 10 (tipo Long).
  db.alumno.insert( { _id:NumberLong(10), name:"Raquel",apellidos:"Gutierrez Garcia"} )</p>
<p>Si queremos insertar múltiples documentos,podemos hacer la inserción más rápida utilizando batch inserts, que permiten insertar en bloque un array de documentos a la colección. Esto se consigue con solo pasar un array de objetos al comando insert.
  db.numerosprimos.insert(
  [{_id:2},{_id:3},{_id:5},{_id:7},{_id:11},{_id:13},{_id:17},{_id:19},
  {_id:23}] )</p>
<p>=== Borrado ===
Vaya con cuidado, eliminar colecciones completas es muy sencillo en Mongo. Esto borrará todo, tanto la colección como meta propiedades asociadas a ella o
índices creados sobre campos.
  db.alumno.drop()
Por otra parte, para eliminar solo documentos de una colección, tenemos el comando remove, que recibe como parámetro el criterio de borrado en forma de documento JSON. En ese caso, solo los documentos que cumplen el criterio se eliminarán de la colección.
  db.numerosprimos.remove( {_id:23} )</p>
<p>=== Modificación ===
Para modificar un documento se utiliza el método update. Este método recibe dos parámetros, el primero es el criterio de actualización, y el segundo el modificador, que describe los cambios que deben realizarse.</p>
<p>Tenemos dos tipos de actualización. El cambio completo del documento o reemplazo y la modificación de algunos elementos del documento</p>
<p>Veamos un ejemplo de reemplazo. Creamos un elemento con los siguientes datos:<br />
  db.usuarios.insert({name:"jose",friends:32,enemies:2})</p>
<p>El documento seria:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "friends" : 32,
    "enemies" : 2
  }  </p>
<p>Ahora lo reemplazamos:
  db.usuarios.update( {name:"jose"}, {name:"jose",relationships: {friends:32,enemies:2}})</p>
<p>Y quedaría así:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "relationships" : {
       "friends" : 32,
       "enemies" : 2
    }
  }</p>
<p>Si lo que queremos es modificar algunos campos utilizaremos el insert, pero con modificadores. Veámoslos:</p>
<p><strong>$set</strong></p>
<p>Asigna el valor a un campo. Si el campo todavía no existe en el documento lo creará. Se utiliza en el segundo parámetro que se le pasa al comando update.
  db.alumno.insert( { name:"Arturo", apellidos:"Leon Zapata" })
  db.alumno.update( {name:"Arturo"}, { $set: {edad:17} })</p>
<p>Podemos darle valor a varios campos a la vez, simplemente informando los pares clave:valor separados por coma. En este ejemplo damos valor a tres campos diferentes con un solo comando.
  db.alumno.update( {name:"Arturo"}, { $set:{nota:8.2,orden:12,actitud:"positiva"} })</p>
<p><strong>$unset</strong></p>
<p>Para eliminar cualquier campo de uno o varios documentos lo hacemos también con el comando update pero con el modificador $unset.
En MongoDB es habitual utilizar los valores 1 y -1 para indicar verdadero y falso respectivamente. En este caso, al especificar valor 1 estamos diciendo que la
clave entra dentro del conjunto de campos en los que queremos aplicar el $unset.
De esta forma, si queremos eliminar el campo “edad” del documento que guarda la información del alumno “Arturo”, lo haríamos así.
  db.alumno.update({name:"Arturo"},{$unset:{edad:1}})</p>
<p><strong>$inc</strong></p>
<p>Este modificador puede utilizarse para incrementar o decrementar el valor numérico de una clave existente o para crear una nueva si no existe.
  db.alumno.update({name:"Arturo"},{$inc:{puntuacion:2}})</p>
<p>Otros operadores que podemos utilizar de forma similar son <strong>$mul, $min, $max y $currentDate</strong>.
  db.alumno.update({name:"Arturo"},{$min:{puntuacion:3}})
El ejmplo de arriba modifica la puntuacion si esta es menor que3</p>
<p>Ahora vamos a ver modificadores de arrays.
<strong>$push</strong>
Se utiliza para añadir elementos a un array. Si el array no existe lo crea con los elementos indicados en el push, y si ya existe los añade al final del array.
  db.alumno.insert({name:"Sofia", apellidos:"Alarcon Sevilla"})
  db.alumno.update({name:"Sofia"},{$push:{"asignaturas":{name:"Matematicas", nota:9.1}}})</p>
<p><strong>$pull</strong></p>
<p>Hay varias formas de eliminar elementos de un array. Cuando queremos borrar elementos basados en algún criterio, el modificador adecuado es $pull.
Partimos de un array y borraremos elementos
  db.lists.insert({"todo": ["lavar platos", "colada", "tender"]})
Para eliminar la colada haríamos.
  db.lists.update({},{$pull:{"todo":"colada"}})</p>
<p><strong>$pop</strong></p>
<p>Para eliminar el primer o último elemento del array.
Para eliminar el último elemento del array:
  db.lists.update({},{$pop:{todo:1}})
Para eliminar el prtimer elemento del array:
  db.lists.update({},{$pop:{todo:-1}})</p>
<p><strong>Upserts</strong></p>
<p>Un upsert es un tipo de update espcial. Si no se encuentra ningún documento que haga matching con el criterio del update, entonces se creará un nuevo documento combinando el criterio y lo que se quiere actualizar. Si se encuentra un documento que haga matching se actualizará normalmente.
Para decirle a MongoDB que queremos hacer un upsert, solo hay que pasar al comando update un tercer parámetro, con valor true. Esto significa que el update se comportará como hemos explicado que lo hace el upsert. 
  update({...},{...},true)
  db.alumno.update({name:"Sofia"},{$set:{apellidos:"Alarcon Revilla"}},true)</p>
<p><strong>Multiples Documentos</strong></p>
<p>Para modificar múltiples documentos, en el tercer parámetro del update indicaremos {multi: true}. 
  db.books.update({lang:"en"},{$inc: {price: 50.00}}, {multi:true})</p>
<p>==== Consultas ====
El método find es el que se utiliza para hacer queries en Mongo. Es el equivalente al comando select en el modelo relacional. Al consultar una colección, Mongo nos
devolverá un subconjunto de documentos, que variará desde el conjunto vació hasta la colección completa.
Find tiene varios parámetros de entrada, el primero de ellos especifica los documentos que queremos recuperar, esto es, el criterio de búsqueda.
  db.coleccion1.find({ clave1:valor1 })
La función anterior nos devolvería documentos de la colección coleccion1 cuyo campo clave1 tenga un valor igual a valor1.</p>
<p>El valor por defecto para este primer parámetro es {}, que significa “cualquier documento”. Por tanto una query como db.coleccion1.find({ }) devolverá todos los documentos de la colección coleccion1. Como es el valor por defecto para el criterio de la consulta es equivalente hacer find({ }) y find( ).</p>
<p>db.alumno.find({edad:17})
  db.alumno.find({name:"Antonio"})</p>
<p>Igual que en SQL podemos especificar los campos que queremos recuperar (select campo1, campo2, campo3 from tabla ... ), podemos hacerlo también en Mongo. Para ello solo tenemos que pasar un segundo parámetro al método find, en el que decimos los que queremos.
  db.coleccion1.find({ },{ clave3:1, clave4:1 })
Los campos que queremos que sean devueltos les pondremos el valor 1. El campo _id siempre se devuelve. También podemos especificar los campos que no queremos que sean devueltos, en este caso como valor para cada una de esos campos, pondremos cero. El resultado será que se devolverán el resto de documentos.
  db.coleccion1.find({ },{ clave3:0, clave4:0 })</p>
<p>=== Operadores de comparación ===
MongoDB permite utilizar los siguientes operadores de comparación:
  * <strong>$lt</strong> (less than), se corresponde con la condición &lt; (menor estricto).
  * <strong>$lte</strong> (less than or equal), se corresponde con la condición &lt;= (menor o igual).
  * <strong>$gt</strong> (greather than), se corresponde con la condición &gt; (mayor estricto).
  * <strong>$gte</strong> (greather than or equal), se corresponde con la condición &gt;= (mayor o igual).</p>
<p>clave: { $operador: valor }</p>
<p>Así si por ejemplo queremos recuperar los libros con un precio mayor que 10 lo haríamos utilizando el operador $gt sobre el campo precio:
  db.libro.find({"precio":{$gt:10}},{titulo:1,precio:1})</p>
<p>=== Operadores lógicos ===</p>
<p><strong>$in</strong>
  clave: { $in: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave esté entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$in:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$nin</strong>
  clave: { $nin: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave NO esté entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$nin:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$or</strong>
  $or: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que estén en stock (enstock:false) o que tengan editorial (editorial:null).
  db.libro.find({$or:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$nor</strong>
  $nor: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que no estén en stock (enstock:false) o que no tengan editorial (editorial:null).
  db.libro.find({$nor:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$not</strong></p>
<p>$not es lo que se conoce como un metacondicional, que son opeadores que pueden aplicarse por encima de cualquier otro criterio. Su sintaxis es sencilla, solo hay que ponerlo “fuera” de aquello que queremos negar.
  $not: { criterio }
Y así directamente podemos recuperar por ejemplo, documentos que no tengan 480 paginas.
  db.libro.find( { paginas: {$not: { $eq:480 } } },{titulo:1,paginas:1} )</p>
<p><strong>$exist</strong></p>
<p>El operador $exists se utiliza para comprobar los documentos que tienen informado o no un campo determinado. Su sintaxis es la siguiente:
  clave: { $exists: boolean}
Donde boolean puede ser true o false. En el caso de true devuelve documentos que tienen informado un campo, aunque su valor sea null. Este operador es útil porque debido a la ausencia de definición de esquema de datos de mongo, cada documento de una misma colección puede tener los campos que requiera, y al hacer consultas puede que no nos devuelva ciertos documentos bien porque no entra dentro de los valores exigidos, bien porque el campo no está definido.
Veamos un ejemplo con dos comandos find donde utilizamos el operador $exists con ambos valores.
  db.libro.find({paginas:{$exists:true}},{paginas:1})</p>
<p><note important><strong>null</strong> tiene un comportamiento un poco extraño, ya que hace matching en los siguientes casos:
  * Con valores que almacenan null, por ejemplo “y” : null
  * Con campos que no existen en un documento. Si por ejemplo el documentoA no tiene informado el campo x, una búsqueda por { x:null } sí que se encontraría.</p>
<p></note></p>
<p><strong>Expresiones regulares</strong></p>
<p>MongoDB incluye el trabajo con expresiones regulares de forma nativa.
Ejemplo: Recuperamos los libros del autor Posteguillo, sin preocuparnos por mayúsculas y minúsculas, haríamos esta consulta.
  db.libro.find({autor:/posteguillo/i},{titulo:1,autor:1}).pretty()</p>
<p><strong>Búsqueda de texto</strong></p>
<p>En MongoDB, podemos realizar búsquedas de texto usando el índice de texto y el operador $text. Pasos:</p>
<p>Primero se crea un índice de texto en los  campos para realizar la búsqueda de  texto. </p>
<p>db.books.createIndex({"title":"text"})   //---  Un campo//
  db.books.createIndex({"title":"text","autor":"text"}) //---  Varios campos//</p>
<p>Luego se realiza la busqueda con $text. La expresión $text tiene la siguiente sintaxis:
  {
    $text:
    {
        $search: <string>,
        $lenguage: <string>, Opcional
        $caseSensitive: <boolean>,Opcional
        $diacriticSensitive: <boolean> Opcional
    }
  }</p>
<p>Ejemplos:</p>
<p>db.books.find({
           $text:{$search:"la",$caseSensitive:true}
           })</p>
<p>db.books.find({
           $text:{$search:"la -Biblia"}    //--- Busca "la" pero no "Biblia"//
          }) </p>
<p>==== Consultas con Arrays ====</p>
<p>Creamos una colección para ver los ejemplos
  db.comida.insert({fruta:["manzana","platano","pera"]})</p>
<p>Para buscar documentos que tengan un elemento concreto dentro del array, es tan simple como poner el nombre del array y el valor que queremos encontrar.
  db.comida.findOne({fruta:"pera"})</p>
<p>Podemos utilizar cualquiera de los operadores aprendidos hasta el momento, como por ejemplo $in, para recuperar documentos que tengan alguno de los
valores especificados.
  db.comida.findOne({fruta: { $in:["pera","platano","melocoton"] }})</p>
<p>Si necesita recuperar arrays que contengan más de un elemento, puede utilizar el operador $all, que permite especificar una lista de elementos.
Modificamos la colección para ver unos ejemplos
  db.comida.drop()
  db.comida.insert({_id:1, fruta:["manzana","platano","melocoton"]})
  db.comida.insert({_id:2, fruta:["manzana","kiwi","naranja"]})
  db.comida.insert({_id:3, fruta:["cerezas","platano","manzana"]})</p>
<p>Si ahora queremos documentos que tengan los elementos platano y manzana, lo haremos con $all de esta forma.
  db.comida.find({fruta: { $all:["platano","manzana"]}})</p>
<p>Para recuperar documentos que tengan un valor concreto en cierto índice delarray, se consigue poniendo dicho índice (empezando desde cero) tras un punto
del array. Es decir: fruta.0 es el primer elemento del array.
  db.comida.find({"fruta.0":"cerezas"})</p>
<p><strong>$size</strong></p>
<p>Un condicional útil para las consultas contra arrays es $size, que permite recuperar arrays que tienen un determinado tamaño.
La siguiente consulta muestra los documentos que tenga 2 frutas.
  db.comida.find({fruta:{$size:2}})</p>
<p><strong>$slice</strong></p>
<p>El operador $slice se utiliza para devolver un subconjunto de los elementos delarray. No influye en el criterio de búsqueda, solo es para especificar a mongo lo
que queremos que nos devuelva. Su sintaxis es la siguiente.
  clave: { $slice: x}
Donde según x:
  * x es un entero positivo (p.ej 10), devuelve los primeros x elementos del array clave.
  * x es un entero negativo (p.ej -10), devuelve los últimos x elementos del array clave.
  * x es un array (p.ej [2,4], devuelve los elementos desde el 2 al 4, ambos incluidos.</p>
<p>Ejemplos:
  db.comida.find({},{fruta:{$slice:2}})
  db.comida.find({},{fruta:{$slice:-2}})
  db.comida.find({},{fruta:{$slice:[1,3]}})</p>
<p><strong>Conjuntos de valores</strong></p>
<p>Si queremos obtener todos los diferentes valores que existen en un campo, utilizaremos el método distinct
  db.grades.distinct('type')</p>
<p><strong>Contar valores</strong></p>
<p>Para contar el número de documentos, en vez de find usaremos el método count. Por ejemplo:
  db.grades.count({type:"exam"})
  db.grades.find({type:"exam"}).count() 
  db.grades.count({type:"essay", score:{$gt:90}})
==== Documentos embebidos ====</p>
<p>Para hacer queries contra campos de documentos embebidos dentro de otros documentos, solamente hay que poner la “ruta” completa de claves separada por puntos. Es decir, si tenemos por ejemplo una estructura como esta para los libros.
  db.libro.save({
          "_id":"9788408117117",
          "titulo":"Circo Máximo",
          "autor": {
                    nombre:"Santiago",
                    apellidos:"Posteguillo Gómez",
                    nacimiento: {
                                 anyo:1967,
                                 ciudad:"Valencia"
                   }
          },
         "editorial":"Planeta",
         "enstock":true,
         "paginas":1100,
         "precio":21.75
  })</p>
<p>Podemos lanzar queries directamente contra los documentos embebidos, autor y nacimiento de esta forma. Para re
  db.libro.findOne({"autor.nombre":"Santiago"})</p>
<p>El find anterior recuperará el primer documento donde el campo nombre, del campo autor sea “Santiago”.</p>
<p>db.libro.findOne({"autor.nacimiento.anyo":{$gt:1965}})
El find anterior recuperará el primer documento donde el campo anyo, del campo nacimiento, del campo autor sea mayor que 1965.
==== Cursores ====
La base de datos devuelve resultados para find utilizando cursores, que realmente es un puntero a los resultados de una query, no los resultados en si
mismos. Los clientes integrados con Mongo, iteran sobre los cursores para recuperar los resultados, y ofrecen un conjunto de funcionalidades como limitar
el número de resultados, saltar para no tener que recuperar obligatoriamente los primeros, ordenarlos, etc.</p>
<p>Las opciones de query más comunes son limitar el número de resultados, saltar un número de resultados, y ordenarlos. Todas estas opciones deben especificarse en la propia query al sistema.</p>
<p>Para fijar un límite, debe concatenar la función <strong>limit</strong> tras la función find. Por ejemplo, para solo recuperar los primeros tres libros almacenados, use esto:
  db.libro.find({},{titulo:1}).limit(3)</p>
<p>La función <strong>skip</strong> para “saltar” algunos resultados, funciona de forma similar a limit, concatenándola tras find. Con el siguiente skip(3) saltamos los primeros
tres títulos, y el cursor empezará a devolver a partir del cuarto.
 db.libro.find({},{titulo:1}).skip(3)</p>
<p>La función <strong>sort</strong> sirve para ordenar los resultados que se devuelven. Recibe un objeto json con las claves y un valor 1 (para ordenación ascendente) o -1 (para ordenación descendente).
  db.libro.find({},{titulo:1,precio:1,paginas:1}).sort({precio:1,paginas:-1})</p>
<p>Estas tres funciones, limit, skip y sort, pueden combinarse como se quiera para recuperar exactamente lo que queramos.
  db.libro.find({},{titulo:1,precio:1,paginas:1}).limit(3).skip(2).sort({precio:1, paginas:-1}).pretty()</p>
<p>==== Agregación ====
Una vez tenemos datos almacenados en MongoDB, queremos hacer más que solamente recuperarlos, queremos analizarlos de diversas formas interesantes. 
Esto lo conseguimos con la función de agregación que Mongo ofrece.
La agregación nos permite transformar y combinar documentos en una colección. Básicamente, se construye un pipeline (secuencia de comandos) 
que procesan un conjunto de documentos a través de varios “bloques”: filtrado, proyecciones, agrupaciones, ordenación, limitación y skipping.</p>
<p>Por ejemplo, si de la colección de libros de ejemplo quisiéramos saber los tres autores con más libros escritos, crearíamos un pipeline con los siguientes pasos:
  * Proyectaríamos el autor de cada libro.0
  * Agruparíamos los autores por nombre, contando el número de ocurrencias.
  * Ordenaríamos los autores por dicho número de ocurrencias, descendentemente.
  * Limitaríamos el resultado a los primeros tres.</p>
<p>Cada uno de estos pasos se corresponde con un operador de agregación</p>
<ol>
<li>
<p>{“<strong>$project” : { “autor” : 1 }}</strong> Esto “proyecta/extrae” el autor de cada documento. La sintaxis es similar al selector  de  campos  utilizado  con  find  (el  segundo  parámetro), 
especificando  “nombrecampo”:  1  para  incluir  o  “nombrecampo”:0  para excluir.
Después de esta operación, cada documento de los  resultados es algo así: 
{“_id”:id,  “autor”:”nombre  de  autor”}.  Estos  resultados  solo  existen  en memoria, no se escribirán nunca a disco</p>
</li>
<li>
<p __id_:_nombre="“_id”:”nombre" _count_:="“count”:" autor_="autor”," de="de" numeroDeLibros="numeroDeLibros"><strong>{“$group” : { “_id”:”$autor”, “count”: {“$sum”:1}}}</strong>  Eso agrupa por autores e incrementa “count” para cada documento en los que el autor aparece.
Primero especificamos el campo por el que queremos agrupar, que es “autor”. Esto lo indicamos con el “_id”:”$autor”. Podríamos entenderlo 
como: tras el Group habrá un documento resultado para cada autor, por lo que “autor” se convertirá en el identificador único (“_id”).
El segundo campo significa añadir 1 al campo “count” para cada documento en el grupo. Fíjese  que los documentos de entrada (libro) no tienen el 
campo “count”, es un nuevo campo creado por el “$group”.
Al final de este paso, cada documento resultado es algo como: </p>
</li>
<li>
<p><strong>{“$sort” : {“count” : -1}}</strong> Esto reordena los resultados por el valor del campo “count” 
descendentemente (-1). En caso de ascendente sería “count”:1.</p>
</li>
<li>
<p><strong>{“$limit” : 3}</strong>  Limita el número de resultados a los primeros tres.</p>
</li>
</ol>
<p>Veamos todo esto con más detalle y partiendo de un ejemplo con una colección de libros</p>
<p 1="1" :=":" Casanovas_="Casanovas&quot;," _Anna="&quot;Anna" __id_="&quot;_id&quot;" _count_="&quot;count&quot;"><sxh php>
db.libro.aggregate({$project:{autor:1}},
                   {$group:{_id:"$autor",count:{$sum:1}}},
                   {$sort:{count:-1}},{$limit:3}
                  )
</sxh>
  { "_id" : "Santiago Posteguillo", "count" : 3 }
  { "_id" : "George R.R. Martin", "count" : 2 }</p>
<p>=== Operaciones Pipeline ===
Cada operador recibe un conjunto de documentos, hace algún tipo de transformación sobre ellos, y después pasa el resultado de la transformación. 
Esto es lo que se conoce como pipeline.</p>
<p>{{ :clase:iabd:bda:mongodb.png?600 |}}</p>
<p>== Operador $match ==</p>
<p>El operador $match filtra documentos de forma que podamos ejecutar una agregación sobre un subconjunto de documentos.
$match puede utilizar todos los operadores para query estudiados ($gt, $lt, $in, etc).
Con el siguiente ejemplo, filtraríamos solo aquellos libros con un precio mayor que 20, reduciendo el conjunto inicial de documentos y formando la entrada de 
los siguientes pasos del pipeline.
<sxh php>db.libro.aggregate({$match:{precio:{$gt:20}}})</sxh></p>
<p>Como hemos comentado, cualquiera de las condiciones estudiadas del find podemos utilizarlas con match. Como por ejemplo, los libros en stock. 
<sxh php>db.libro.aggregate({$match:{enstock:true}}) </sxh></p>
<p>== Operador $project ==
La “proyección” es mucho más potente en el pipeline que en el lenguaje “normal”  de la query. $project nos permite extraer campos de subdocumentos, renombrar  campos, y realizar operaciones interesantes sobre ellos. 
La operación más sencilla de $project realiza una selección simple de unos documentos de entrada, es decir, de los documentos de entrada con campos a, b, c y d, con $project decimos que nos quedamos únicamente con a y c. Para incluir o excluir un campo, se utiliza la misma sintaxis que para el segundo argumento de una query, es decir “nombrecampo”: 1 para incluir o “nombrecampo”:0 para excluir. Por defecto, el campo “_id” siempre se devuelve si existe en los documentos de entrada. Lo podemos eliminar por ejemplo utilizando $project de la siguiente forma, en la que devolveríamos todos los campos excepto “_id”. {$project:{ “_id”:0 }}  Con $project también podemos renombrar el campo proyectado. </p>
<p>Por ejemplo si queremos devolver el campo “_id” de los libros como “isbn” haríamos esto. 
<sxh sql>
db.libro.aggregate({$project:{isbn:"$_id"}})
</sxh></p>
<p>La clave está en $_id, cuando ponemos el símbolo del dólar ($) más el nombre de un campo, nos estamos refiriendo al valor que tomará dicho campo para cada documento en el entorno de agregación. Por tanto con $project: {“isbn”:”$_id”} estamos diciendo que proyectamos un nuevo campo isbn como el valor que tendrá el campo _id en cada documento de entrada. 
Igualmente podríamos haber renombrado cualquier otro campo, por ejemplo el campo “enstock” como “disponible”. 
<sxh php>db.libro.aggregate({$project:{isbn:"$_id",disponible:"$enstock"}})</sxh></p>
<p>== Expresiones en el Pipeline ==</p>
<p>La operaciones más simples en $project son inclusión, exclusión y nombres de campo (“$nombrecampo”).<br />
Aunque hay otras más, mucho más potentes. Podemos utilizar expresiones, que nos permiten combinar múltiples literales y variables en un valor único. </p>
<p><strong>Expresiones matemáticas</strong>. </p>
<p>Las expresiones matemáticas nos permiten manipular valores numéricos contra los que operar, y que normalmente se especifican en un array. </p>
<p>Esta es la sintaxis para cada operador matemático. 
  * “$add”: [ expr1, expr2, ... , exprN ]. Toma uno o mas expresiones y las suma. 
  * “$substract”: [ expr1, expr2 ]. Resta la expr2 a la expr1. 
  * “$multiply”: [ expr1, expr2, ..., expón ]. Toma una o más expresiones y las multiplica. 
  * “$divide”: [ expr1, expr2 ]. Divide la expr1 entre la expr2. 
  * “$mod”: [ expr1, expr2 ]. Divide la expr1 entre la expr2 y devuelve el resto. </p>
<p><strong>Expresiones de fechas</strong>. </p>
<p>Muchas agregaciones son basadas en el tiempo. ¿Qué ocurrió la semana pasada? ¿Y el mes pasado?. Es por esto que el entorno de agregación  tiene  un  conjunto  de  expresiones  que  pueden  utilizarse  para  extraer información sobre fechas de una forma muy usable, son: “$year”, “$month”,“$week”, “$dayOfMonth”, “$dayOfWeek”, “$dayOfYear”, “$hour”, “$minute” y “$second”. </p>
<p>Con siguiente sentencia de agregación vamos a recuperar tanto la fecha, como el año de dicha fecha, gracias a la expresión “$year”.</p>
<p><sxh php>db.libro.aggregate({$project:{fecha:1,year:{$year:"$fecha* }}})</sxh></p>
<p><strong>Expresiones de Strings</strong>.</p>
<p>Hay una pocas operaciones básicas sobre cadenas de caracteres que también podemos utilizar. Son 
estas: </p>
<p>“$substr”: [ expr, start, length ]. Devuelve el substring de la expresión expr, empezando en la posición start de la cadena y devolviendo desde ahí un total de length caracteres. En el siguiente ejemplo proyectamos un campo inicio los primeros quince caracteres del campo título.<br />
<sxh php>db.libro.aggregate({$project: {inicio:{$substr: ["$titulo",0,15] }}})</sxh></p>
<p>“$concat”: [ expr1, expr2, ..., exprN ]. Devuelve un nuevo string resultado de la concatenación de expr1, expr2 y así hasta exprN. En el siguiente ejemplo proyectamos un campo descripción en el que concatenamos el titulo, un guión, y el autor.<br />
<sxh php>db.libro.aggregate({$project:{descripcion:{$concat:["$titulo"," - ","$autor"]},_id:0}})</sxh></p>
<p>“$toLower”: expr. Devuelve un string en minúsculas. 
“$toUpper”: expr. Devuelve un string en mayúsculas. </p>
<p><strong>Expresiones lógicas</strong>.</p>
<p>Existen algunas operaciones lógicas que podemos utilizar. Replanteamos el ejemplo anterior de la proyección del campo “barato” utilizando  uno de estos comparadores.  </p>
<p><sxh php>db.libro.aggregate({$project:{barato:{$gt:[15,"$precio"]},precio:1} })</sxh></p>
<p>== Operador $sort ==
Podemos ordenar por cualquier campo o conjunto de campos utilizando la misma sintaxis que para las queries “normales”. Si tenemos que ordenar un número de documentos muy elevado, es recomendable desde el punto de vista del rendimiento, que hagamos la ordenación al principio del pipeline y además tengamos un índice por el conjunto de campos por los que ordenar. De otra forma, $sort puede ser lento y consumir mucha memoria. 
Se pueden utilizar tanto campos existentes como campos proyectados para ordenar. De esta forma podemos por ejemplo completar la agregración en la que calculábamos la media aritmética del precio de los libros por autor, y ordenar los resultados por dicha media calculada ascendentemente. </p>
<p><sxh php>
db.libro.aggregate({$group:{_id:"$autor", media:{$avg:"$precio"}}},
                   {$sort:{media:1}}
                  )
</sxh></p>
<p>Para ordenar cada campo es valor 1, para ordenación ascendente y -­‐1 para descendente. En el siguiente ejemplo ordenamos primero por precio descendente y después por páginas ascendente.
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}}
                  )
</sxh></p>
<p>== Operador $limit ==</p>
<p>La función $limit toma un número N y devuelve los primeros N documentos resultantes. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}},
                   {$limit:3}
                  )
</sxh></p>
<p>== Operador $skip ==</p>
<p>La función $skip toma un número N y desecha los primeros N documentos del conjunto de resultados. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio :-1,paginas:1}},
                   {$skip:3}
                  )
</sxh></p>
<p>== operador $unwind. ==</p>
<p>Dentro de una agregación podemos utilizar el operador $unwind, se podría traducir como "aplanar" ya que aplana los datos
de un array convirtiéndo sus elementos en documentos independientes. Puede ser útil para poder acceder al interior de los
elementos de un array cuando estos no son atómicos.</p>
<p><sxh php>
db.usuario.aggregate({$project: {comentarios:1}},
                     {$unwind :"$comentarios" }
                    )
</sxh>evueltos les pondremos el valor 1. El campo _id siempre se devuelve. También podemos especificar los campos que no queremos que sean devueltos, en este caso como valor para cada una de esos campos, pondremos cero. El resultado será que se devolverán el resto de documentos.
  db.coleccion1.find({ },{ clave3:0, clave4:0 })</p>
<p>=== Operadores de comparación ===
MongoDB permite utilizar los siguientes operadores de comparación:
  * <strong>$lt</strong> (less than), se corresponde con la condición &lt; (menor estricto).
  * <strong>$lte</strong> (less than or equal), se corresponde con la condición &lt;= (menor o igual).
  * <strong>$gt</strong> (greather than), se corresponde con la condición &gt; (mayor estricto).
  * <strong>$gte</strong> (greather than or equal), se corresponde con la condición &gt;= (mayor o igual).</p>
<p>clave: { $operador: valor }</p>
<p>Así si por ejemplo queremos recuperar los libros con un precio mayor que 10 lo haríamos utilizando el operador $gt sobre el campo precio:
  db.libro.find({"precio":{$gt:10}},{titulo:1,precio:1})</p>
<p>=== Operadores lógicos ===</p>
<p><strong>$in</strong>
  clave: { $in: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave esté entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$in:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$nin</strong>
  clave: { $nin: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave NO esté entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$nin:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$or</strong>
  $or: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que estén en stock (enstock:false) o que tengan editorial (editorial:null).
  db.libro.find({$or:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$nor</strong>
  $nor: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que no estén en stock (enstock:false) o que no tengan editorial (editorial:null).
  db.libro.find({$nor:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$not</strong></p>
<p>$not es lo que se conoce como un metacondicional, que son opeadores que pueden aplicarse por encima de cualquier otro criterio. Su sintaxis es sencilla, solo hay que ponerlo “fuera” de aquello que queremos negar.
  $not: { criterio }
Y así directamente podemos recuperar por ejemplo, documentos que no tengan 480 paginas.
  db.libro.find( { paginas: {$not: { $eq:480 } } },{titulo:1,paginas:1} )</p>
<p><strong>$exist</strong></p>
<p>El operador $exists se utiliza para comprobar los documentos que tienen informado o no un campo determinado. Su sintaxis es la siguiente:
  clave: { $exists: boolean}
Donde boolean puede ser true o false. En el caso de true devuelve documentos que tienen informado un campo, aunque su valor sea null. Este operador es útil porque debido a la ausencia de definición de esquema de datos de mongo, cada documento de una misma colección puede tener los campos que requiera, y al hacer consultas puede que no nos devuelva ciertos documentos bien porque no entra dentro de los valores exigidos, bien porque el campo no está definido.
Veamos un ejemplo con dos comandos find donde utilizamos el operador $exists con ambos valores.
  db.libro.find({paginas:{$exists:true}},{paginas:1})</p>
<p><note important><strong>null</strong> tiene un comportamiento un poco extraño, ya que hace matching en los siguientes casos:
  * Con valores que almacenan null, por ejemplo “y” : null
  * Con campos que no existen en un documento. Si por ejemplo el documentoA no tiene informado el campo x, una búsqueda por { x:null } sí que se encontraría.</p>
<p></note></p>
<p><strong>Expresiones regulares</strong></p>
<p>MongoDB incluye el trabajo con expresiones regulares de forma nativa.
Ejemplo: Recuperamos los libros del autor Posteguillo, sin preocuparnos por mayúsculas y minúsculas, haríamos esta consulta.
  db.libro.find({autor:/posteguillo/i},{titulo:1,autor:1}).pretty()</p>
<p><strong>Búsqueda de texto</strong></p>
<p>En MongoDB, podemos realizar búsquedas de texto usando el índice de texto y el operador $text. Pasos:</p>
<p>Primero se crea un índice de texto en los  campos para realizar la búsqueda de  texto. </p>
<p>db.books.createIndex({"title":"text"})   //---  Un campo//
  db.books.createIndex({"title":"text","autor":"text"}) //---  Varios campos//</p>
<p>Luego se realiza la busqueda con $text. La expresión $text tiene la siguiente sintaxis:
  {
    $text:
    {
        $search: <string>,
        $lenguage: <string>, Opcional
        $caseSensitive: <boolean>,Opcional
        $diacriticSensitive: <boolean> Opcional
    }
  }</p>
<p>Ejemplos:</p>
<p>db.books.find({
           $text:{$search:"la",$caseSensitive:true}
           })</p>
<p>db.books.find({
           $text:{$search:"la -Biblia"}    //--- Busca "la" pero no "Biblia"//
          }) </p>
<p>==== Consultas con Arrays ====</p>
<p>Creamos una colección para ver los ejemplos
  db.comida.insert({fruta:["manzana","platano","pera"]})</p>
<p>Para buscar documentos que tengan un elemento concreto dentro del array, es tan simple como poner el nombre del array y el valor que queremos encontrar.
  db.comida.findOne({fruta:"pera"})</p>
<p>Podemos utilizar cualquiera de los operadores aprendidos hasta el momento, como por ejemplo $in, para recuperar documentos que tengan alguno de los
valores especificados.
  db.comida.findOne({fruta: { $in:["pera","platano","melocoton"] }})</p>
<p>Si necesita recuperar arrays que contengan más de un elemento, puede utilizar el operador $all, que permite especificar una lista de elementos.
Modificamos la colección para ver unos ejemplos
  db.comida.drop()
  db.comida.insert({_id:1, fruta:["manzana","platano","melocoton"]})
  db.comida.insert({_id:2, fruta:["manzana","kiwi","naranja"]})
  db.comida.insert({_id:3, fruta:["cerezas","platano","manzana"]})</p>
<p>Si ahora queremos documentos que tengan los elementos platano y manzana, lo haremos con $all de esta forma.
  db.comida.find({fruta: { $all:["platano","manzana"]}})</p>
<p>Para recuperar documentos que tengan un valor concreto en cierto índice delarray, se consigue poniendo dicho índice (empezando desde cero) tras un punto
del array. Es decir: fruta.0 es el primer elemento del array.
  db.comida.find({"fruta.0":"cerezas"})</p>
<p><strong>$size</strong></p>
<p>Un condicional útil para las consultas contra arrays es $size, que permite recuperar arrays que tienen un determinado tamaño.
La siguiente consulta muestra los documentos que tenga 2 frutas.
  db.comida.find({fruta:{$size:2}})</p>
<p><strong>$slice</strong></p>
<p>El operador $slice se utiliza para devolver un subconjunto de los elementos delarray. No influye en el criterio de búsqueda, solo es para especificar a mongo lo
que queremos que nos devuelva. Su sintaxis es la siguiente.
  clave: { $slice: x}
Donde según x:
  * x es un entero positivo (p.ej 10), devuelve los primeros x elementos del array clave.
  * x es un entero negativo (p.ej -10), devuelve los últimos x elementos del array clave.
  * x es un array (p.ej [2,4], devuelve los elementos desde el 2 al 4, ambos incluidos.</p>
<p>Ejemplos:
  db.comida.find({},{fruta:{$slice:2}})
  db.comida.find({},{fruta:{$slice:-2}})
  db.comida.find({},{fruta:{$slice:[1,3]}})</p>
<p><strong>Conjuntos de valores</strong></p>
<p>Si queremos obtener todos los diferentes valores que existen en un campo, utilizaremos el método distinct
  db.grades.distinct('type')</p>
<p><strong>Contar valores</strong></p>
<p>Para contar el número de documentos, en vez de find usaremos el método count. Por ejemplo:
  db.grades.count({type:"exam"})
  db.grades.find({type:"exam"}).count() 
  db.grades.count({type:"essay", score:{$gt:90}})
==== Documentos embebidos ====</p>
<p>Para hacer queries contra campos de documentos embebidos dentro de otros documentos, solamente hay que poner la “ruta” completa de claves separada por puntos. Es decir, si tenemos por ejemplo una estructura como esta para los libros.
  db.libro.save({
          "_id":"9788408117117",
          "titulo":"Circo Máximo",
          "autor": {
                    nombre:"Santiago",
                    apellidos:"Posteguillo Gómez",
                    nacimiento: {
                                 anyo:1967,
                                 ciudad:"Valencia"
                   }
          },
         "editorial":"Planeta",
         "enstock":true,
         "paginas":1100,
         "precio":21.75
  })</p>
<p>Podemos lanzar queries directamente contra los documentos embebidos, autor y nacimiento de esta forma. Para re
  db.libro.findOne({"autor.nombre":"Santiago"})</p>
<p>El find anterior recuperará el primer documento donde el campo nombre, del campo autor sea “Santiago”.</p>
<p>db.libro.findOne({"autor.nacimiento.anyo":{$gt:1965}})
El find anterior recuperará el primer documento donde el campo anyo, del campo nacimiento, del campo autor sea mayor que 1965.
==== Cursores ====
La base de datos devuelve resultados para find utilizando cursores, que realmente es un puntero a los resultados de una query, no los resultados en si
mismos. Los clientes integrados con Mongo, iteran sobre los cursores para recuperar los resultados, y ofrecen un conjunto de funcionalidades como limitar
el número de resultados, saltar para no tener que recuperar obligatoriamente los primeros, ordenarlos, etc.</p>
<p>Las opciones de query más comunes son limitar el número de resultados, saltar un número de resultados, y ordenarlos. Todas estas opciones deben especificarse en la propia query al sistema.</p>
<p>Para fijar un límite, debe concatenar la función <strong>limit</strong> tras la función find. Por ejemplo, para solo recuperar los primeros tres libros almacenados, use esto:
  db.libro.find({},{titulo:1}).limit(3)</p>
<p>La función <strong>skip</strong> para “saltar” algunos resultados, funciona de forma similar a limit, concatenándola tras find. Con el siguiente skip(3) saltamos los primeros
tres títulos, y el cursor empezará a devolver a partir del cuarto.
 db.libro.find({},{titulo:1}).skip(3)</p>
<p>La función <strong>sort</strong> sirve para ordenar los resultados que se devuelven. Recibe un objeto json con las claves y un valor 1 (para ordenación ascendente) o -1 (para ordenación descendente).
  db.libro.find({},{titulo:1,precio:1,paginas:1}).sort({precio:1,paginas:-1})</p>
<p>Estas tres funciones, limit, skip y sort, pueden combinarse como se quiera para recuperar exactamente lo que queramos.
  db.libro.find({},{titulo:1,precio:1,paginas:1}).limit(3).skip(2).sort({precio:1, paginas:-1}).pretty()</p>
<p>==== Agregación ====
Una vez tenemos datos almacenados en MongoDB, queremos hacer más que solamente recuperarlos, queremos analizarlos de diversas formas interesantes. 
Esto lo conseguimos con la función de agregación que Mongo ofrece.
La agregación nos permite transformar y combinar documentos en una colección. Básicamente, se construye un pipeline (secuencia de comandos) 
que procesan un conjunto de documentos a través de varios “bloques”: filtrado, proyecciones, agrupaciones, ordenación, limitación y skipping.</p>
<p>Por ejemplo, si de la colección de libros de ejemplo quisiéramos saber los tres autores con más libros escritos, crearíamos un pipeline con los siguientes pasos:
  * Proyectaríamos el autor de cada libro.0
  * Agruparíamos los autores por nombre, contando el número de ocurrencias.
  * Ordenaríamos los autores por dicho número de ocurrencias, descendentemente.
  * Limitaríamos el resultado a los primeros tres.</p>
<p>Cada uno de estos pasos se corresponde con un operador de agregación</p>
<ol>
<li>
<p>{“<strong>$project” : { “autor” : 1 }}</strong> Esto “proyecta/extrae” el autor de cada documento. La sintaxis es similar al selector  de  campos  utilizado  con  find  (el  segundo  parámetro), 
especificando  “nombrecampo”:  1  para  incluir  o  “nombrecampo”:0  para excluir.
Después de esta operación, cada documento de los  resultados es algo así: 
{“_id”:id,  “autor”:”nombre  de  autor”}.  Estos  resultados  solo  existen  en memoria, no se escribirán nunca a disco</p>
</li>
<li>
<p __id_:_nombre="“_id”:”nombre" _count_:="“count”:" autor_="autor”," de="de" numeroDeLibros="numeroDeLibros"><strong>{“$group” : { “_id”:”$autor”, “count”: {“$sum”:1}}}</strong>  Eso agrupa por autores e incrementa “count” para cada documento en los que el autor aparece.
Primero especificamos el campo por el que queremos agrupar, que es “autor”. Esto lo indicamos con el “_id”:”$autor”. Podríamos entenderlo 
como: tras el Group habrá un documento resultado para cada autor, por lo que “autor” se convertirá en el identificador único (“_id”).
El segundo campo significa añadir 1 al campo “count” para cada documento en el grupo. Fíjese  que los documentos de entrada (libro) no tienen el 
campo “count”, es un nuevo campo creado por el “$group”.
Al final de este paso, cada documento resultado es algo como: </p>
</li>
<li>
<p><strong>{“$sort” : {“count” : -1}}</strong> Esto reordena los resultados por el valor del campo “count” 
descendentemente (-1). En caso de ascendente sería “count”:1.</p>
</li>
<li>
<p><strong>{“$limit” : 3}</strong>  Limita el número de resultados a los primeros tres.</p>
</li>
</ol>
<p>Veamos todo esto con más detalle y partiendo de un ejemplo con una colección de libros</p>
<p 1="1" :=":" Casanovas_="Casanovas&quot;," _Anna="&quot;Anna" __id_="&quot;_id&quot;" _count_="&quot;count&quot;"><sxh php>
db.libro.aggregate({$project:{autor:1}},
                   {$group:{_id:"$autor",count:{$sum:1}}},
                   {$sort:{count:-1}},{$limit:3}
                  )
</sxh>
  { "_id" : "Santiago Posteguillo", "count" : 3 }
  { "_id" : "George R.R. Martin", "count" : 2 }</p>
<p>=== Operaciones Pipeline ===
Cada operador recibe un conjunto de documentos, hace algún tipo de transformación sobre ellos, y después pasa el resultado de la transformación. 
Esto es lo que se conoce como pipeline.</p>
<p>{{ :clase:iabd:bda:mongodb.png?600 |}}</p>
<p>== Operador $match ==</p>
<p>El operador $match filtra documentos de forma que podamos ejecutar una agregación sobre un subconjunto de documentos.
$match puede utilizar todos los operadores para query estudiados ($gt, $lt, $in, etc).
Con el siguiente ejemplo, filtraríamos solo aquellos libros con un precio mayor que 20, reduciendo el conjunto inicial de documentos y formando la entrada de 
los siguientes pasos del pipeline.
<sxh php>db.libro.aggregate({$match:{precio:{$gt:20}}})</sxh></p>
<p>Como hemos comentado, cualquiera de las condiciones estudiadas del find podemos utilizarlas con match. Como por ejemplo, los libros en stock. 
<sxh php>db.libro.aggregate({$match:{enstock:true}}) </sxh></p>
<p>== Operador $project ==
La “proyección” es mucho más potente en el pipeline que en el lenguaje “normal”  de la query. $project nos permite extraer campos de subdocumentos, renombrar  campos, y realizar operaciones interesantes sobre ellos. 
La operación más sencilla de $project realiza una selección simple de unos documentos de entrada, es decir, de los documentos de entrada con campos a, b, c y d, con $project decimos que nos quedamos únicamente con a y c. Para incluir o excluir un campo, se utiliza la misma sintaxis que para el segundo argumento de una query, es decir “nombrecampo”: 1 para incluir o “nombrecampo”:0 para excluir. Por defecto, el campo “_id” siempre se devuelve si existe en los documentos de entrada. Lo podemos eliminar por ejemplo utilizando $project de la siguiente forma, en la que devolveríamos todos los campos excepto “_id”. {$project:{ “_id”:0 }}  Con $project también podemos renombrar el campo proyectado. </p>
<p>Por ejemplo si queremos devolver el campo “_id” de los libros como “isbn” haríamos esto. 
<sxh sql>
db.libro.aggregate({$project:{isbn:"$_id"}})
</sxh></p>
<p>La clave está en $_id, cuando ponemos el símbolo del dólar ($) más el nombre de un campo, nos estamos refiriendo al valor que tomará dicho campo para cada documento en el entorno de agregación. Por tanto con $project: {“isbn”:”$_id”} estamos diciendo que proyectamos un nuevo campo isbn como el valor que tendrá el campo _id en cada documento de entrada. 
Igualmente podríamos haber renombrado cualquier otro campo, por ejemplo el campo “enstock” como “disponible”. 
<sxh php>db.libro.aggregate({$project:{isbn:"$_id",disponible:"$enstock"}})</sxh></p>
<p>== Expresiones en el Pipeline ==</p>
<p>La operaciones más simples en $project son inclusión, exclusión y nombres de campo (“$nombrecampo”).<br />
Aunque hay otras más, mucho más potentes. Podemos utilizar expresiones, que nos permiten combinar múltiples literales y variables en un valor único. </p>
<p><strong>Expresiones matemáticas</strong>. </p>
<p>Las expresiones matemáticas nos permiten manipular valores numéricos contra los que operar, y que normalmente se especifican en un array. </p>
<p>Esta es la sintaxis para cada operador matemático. 
  * “$add”: [ expr1, expr2, ... , exprN ]. Toma uno o mas expresiones y las suma. 
  * “$substract”: [ expr1, expr2 ]. Resta la expr2 a la expr1. 
  * “$multiply”: [ expr1, expr2, ..., expón ]. Toma una o más expresiones y las multiplica. 
  * “$divide”: [ expr1, expr2 ]. Divide la expr1 entre la expr2. 
  * “$mod”: [ expr1, expr2 ]. Divide la expr1 entre la expr2 y devuelve el resto. </p>
<p><strong>Expresiones de fechas</strong>. </p>
<p>Muchas agregaciones son basadas en el tiempo. ¿Qué ocurrió la semana pasada? ¿Y el mes pasado?. Es por esto que el entorno de agregación  tiene  un  conjunto  de  expresiones  que  pueden  utilizarse  para  extraer información sobre fechas de una forma muy usable, son: “$year”, “$month”,“$week”, “$dayOfMonth”, “$dayOfWeek”, “$dayOfYear”, “$hour”, “$minute” y “$second”. </p>
<p>Con siguiente sentencia de agregación vamos a recuperar tanto la fecha, como el año de dicha fecha, gracias a la expresión “$year”.</p>
<p><sxh php>db.libro.aggregate({$project:{fecha:1,year:{$year:"$fecha* }}})</sxh></p>
<p><strong>Expresiones de Strings</strong>.</p>
<p>Hay una pocas operaciones básicas sobre cadenas de caracteres que también podemos utilizar. Son 
estas: </p>
<p>“$substr”: [ expr, start, length ]. Devuelve el substring de la expresión expr, empezando en la posición start de la cadena y devolviendo desde ahí un total de length caracteres. En el siguiente ejemplo proyectamos un campo inicio los primeros quince caracteres del campo título.<br />
<sxh php>db.libro.aggregate({$project: {inicio:{$substr: ["$titulo",0,15] }}})</sxh></p>
<p>“$concat”: [ expr1, expr2, ..., exprN ]. Devuelve un nuevo string resultado de la concatenación de expr1, expr2 y así hasta exprN. En el siguiente ejemplo proyectamos un campo descripción en el que concatenamos el titulo, un guión, y el autor.<br />
<sxh php>db.libro.aggregate({$project:{descripcion:{$concat:["$titulo"," - ","$autor"]},_id:0}})</sxh></p>
<p>“$toLower”: expr. Devuelve un string en minúsculas. 
“$toUpper”: expr. Devuelve un string en mayúsculas. </p>
<p><strong>Expresiones lógicas</strong>.</p>
<p>Existen algunas operaciones lógicas que podemos utilizar. Replanteamos el ejemplo anterior de la proyección del campo “barato” utilizando  uno de estos comparadores.  </p>
<p><sxh php>db.libro.aggregate({$project:{barato:{$gt:[15,"$precio"]},precio:1} })</sxh></p>
<p>== Operador $sort ==
Podemos ordenar por cualquier campo o conjunto de campos utilizando la misma sintaxis que para las queries “normales”. Si tenemos que ordenar un número de documentos muy elevado, es recomendable desde el punto de vista del rendimiento, que hagamos la ordenación al principio del pipeline y además tengamos un índice por el conjunto de campos por los que ordenar. De otra forma, $sort puede ser lento y consumir mucha memoria. 
Se pueden utilizar tanto campos existentes como campos proyectados para ordenar. De esta forma podemos por ejemplo completar la agregración en la que calculábamos la media aritmética del precio de los libros por autor, y ordenar los resultados por dicha media calculada ascendentemente. </p>
<p><sxh php>
db.libro.aggregate({$group:{_id:"$autor", media:{$avg:"$precio"}}},
                   {$sort:{media:1}}
                  )
</sxh></p>
<p>Para ordenar cada campo es valor 1, para ordenación ascendente y -­‐1 para descendente. En el siguiente ejemplo ordenamos primero por precio descendente y después por páginas ascendente.
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}}
                  )
</sxh></p>
<p>== Operador $limit ==</p>
<p>La función $limit toma un número N y devuelve los primeros N documentos resultantes. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}},
                   {$limit:3}
                  )
</sxh></p>
<p>== Operador $skip ==</p>
<p>La función $skip toma un número N y desecha los primeros N documentos del conjunto de resultados. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio :-1,paginas:1}},
                   {$skip:3}
                  )
</sxh></p>
<p>== operador $unwind. ==</p>
<p>Dentro de una agregación podemos utilizar el operador $unwind, se podría traducir como "aplanar" ya que aplana los datos
de un array convirtiéndo sus elementos en documentos independientes. Puede ser útil para poder acceder al interior de los
elementos de un array cuando estos no son atómicos.</p>
<p><sxh php>
db.usuario.aggregate({$project: {comentarios:1}},
                     {$unwind :"$comentarios" }
                    )
</sxh></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy"], "search": "../../../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.dff1b7c8.min.js"></script>
      
    
  </body>
</html>