
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.3.1">
    
    
      
        <title>NoSQL - Mis Clases</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.046329b4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bases-de-datos-nosql" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Mis Clases" class="md-header__button md-logo" aria-label="Mis Clases" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mis Clases
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              NoSQL
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Mis Clases" class="md-nav__button md-logo" aria-label="Mis Clases" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Mis Clases
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Inicio
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sistemes Operatius Monolloc
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Sistemes Operatius Monolloc
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema01/SistemesInformatics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Sistemes Inform√†tics
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema02/SistemesOperatius/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T2 - Sistemes Operatius
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SOM/Tema03/GestioRecursos/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T3 - Gestio de Recursos
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Sistemas Big Data
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Sistemas Big Data
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SBD/Tema01/BigDataConAWS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Big Data con AWS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../SBD/Tema01/PracticasAWS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T12 - AWS
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Big Data Aplicado
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Big Data Aplicado
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Tema01/IntroduccionBigData/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T1 - Introducci√≥n Big Data
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../Tema02/RepasoSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    T2 - Repaso SQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#que-son-las-bases-de-datos-nosql" class="md-nav__link">
    ¬øQu√© son las bases de datos NoSQL?
  </a>
  
    <nav class="md-nav" aria-label="¬øQu√© son las bases de datos NoSQL?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#caracteristicas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Caracter√≠sticas de las bases de datos NoSQL:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ventajas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Ventajas de las bases de datos NoSQL:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#desventajas-de-las-bases-de-datos-nosql" class="md-nav__link">
    Desventajas de las bases de datos NoSQL:
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tipos-de-bases-de-datos-nosql" class="md-nav__link">
    Tipos de bases de datos NoSQL:
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>= 3. No 
== 3.1. Bases de datos No SQL </p>
<h1 id="bases-de-datos-nosql">Bases de Datos NoSQL</h1>
<h2 id="que-son-las-bases-de-datos-nosql">¬øQu√© son las bases de datos NoSQL?</h2>
<p>Las bases de datos NoSQL (NoSQL significa "Not Only SQL" o "No Solo SQL") son sistemas de gesti√≥n de bases de datos dise√±ados para manejar tipos de datos y escenarios de aplicaci√≥n que no se ajustan bien a las bases de datos relacionales tradicionales. </p>
<p>A diferencia de las bases de datos SQL, que utilizan un esquema fijo y tablas para almacenar datos, las bases de datos NoSQL utilizan diferentes modelos de datos y estructuras de almacenamiento flexibles.</p>
<h3 id="caracteristicas-de-las-bases-de-datos-nosql">Caracter√≠sticas de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Esquema flexible:</strong> NoSQL permite almacenar datos sin necesidad de un esquema predefinido.</p>
</li>
<li>
<p><strong>Escalabilidad horizontal:</strong> Las bases de datos NoSQL est√°n dise√±adas para escalar horizontalmente.</p>
</li>
<li>
<p><strong>Modelos de datos variados:</strong> Existen varios tipos de bases de datos NoSQL, incluyendo bases de datos de documentos, bases de datos de columnas, bases de datos clave-valor y bases de datos de grafos.</p>
</li>
<li>
<p><strong>Alta disponibilidad:</strong> Las bases de datos NoSQL suelen garantizar la disponibilidad continua de los datos.</p>
</li>
</ul>
<h3 id="ventajas-de-las-bases-de-datos-nosql">Ventajas de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Escalabilidad:</strong> Son ideales para aplicaciones web y m√≥viles que requieren escalabilidad r√°pida y eficiente.</p>
</li>
<li>
<p><strong>Flexibilidad:</strong> Pueden manejar datos no estructurados o semiestructurados.</p>
</li>
<li>
<p><strong>Rendimiento:</strong> Ofrecen un rendimiento m√°s r√°pido para ciertos tipos de consultas.</p>
</li>
</ul>
<h3 id="desventajas-de-las-bases-de-datos-nosql">Desventajas de las bases de datos NoSQL:</h3>
<ul>
<li>
<p><strong>Falta de est√°ndares:</strong> La diversidad de modelos y sistemas NoSQL dificulta la elecci√≥n y la migraci√≥n entre sistemas.</p>
</li>
<li>
<p><strong>Menos soporte para consultas complejas:</strong> No son ideales para aplicaciones que requieren operaciones complejas de tipo JOIN y agregaci√≥n.</p>
</li>
</ul>
<h2 id="tipos-de-bases-de-datos-nosql">Tipos de bases de datos NoSQL:</h2>
<ul>
<li>
<p><strong>Bases de datos de documentos:</strong></p>
</li>
<li>
<p><strong>Explicaci√≥n:</strong> Almacenan datos en formato de documentos semiestructurados, como JSON o XML.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://www.mongodb.com/">MongoDB</a></li>
<li><a href="https://www.couchbase.com/">Couchbase</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos de columnas:</strong></p>
</li>
<li>
<p><strong>Explicaci√≥n:</strong> Almacenan datos en columnas en lugar de filas.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://cassandra.apache.org/">Apache Cassandra</a></li>
<li><a href="https://hbase.apache.org/">HBase</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos clave-valor:</strong></p>
</li>
<li>
<p><strong>Explicaci√≥n:</strong> Almacenan datos como pares de clave y valor.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://redis.io/">Redis</a></li>
<li><a href="http://docs.basho.com/riak/kv/latest/">Riak</a></li>
</ul>
</li>
<li>
<p><strong>Bases de datos de grafos:</strong></p>
</li>
<li>
<p><strong>Explicaci√≥n:</strong> Almacenan datos como nodos y relaciones.</p>
</li>
<li>
<p><strong>Ejemplos:</strong></p>
<ul>
<li><a href="https://neo4j.com/">Neo4j</a></li>
<li><a href="https://aws.amazon.com/neptune/">Amazon Neptune</a></li>
</ul>
</li>
</ul>
<p>Recuerda que cada tipo de base de datos NoSQL tiene sus propias caracter√≠sticas y casos de uso espec√≠ficos. La elecci√≥n depender√° de las necesidades de tu proyecto.</p>
<p>== 3.2. MongoDB 
=== 3.2.1. Conceptos B√°sicos 
Los elementos de MongoDB son:
  * <strong>Bases de Datos</strong>:
    * Act√∫a cada una como un contenedor de alto nivel
  * <strong>Colecciones</strong>:
    * Una base de datos tendr√° 0 o m√°s colecciones. 
    * Una colecci√≥n es muy similar a lo que entendemos como tabla dentro de un SGDB.
  * <strong>Documentos</strong>:
    * Las colecciones contiene 0 o m√°s documentos, por lo que es similar a una fila o registro de un RDMS.</p>
<p>==== 3.2.1.1. Documentos</p>
<p>El coraz√≥n de MongoDB es el documento, un conjunto ordenado de claves con valores asociados. Su representaci√≥n como hemos nombrado en el tema anterior es en JSON, un formato muy intuitivo y que no pensamos que requiera mayor explicaci√≥n. Este podr√≠a ser un ejemplo sencillo de un documento que guarda el nombre, apellidos y dedad de una persona. A la izquierda de los dos puntos el nombre del campo y a la derecha el valor.
'''json
  {
  nombre:‚ÄùJose Antonio‚Äù,
  apellidos:‚ÄùGuillem Benedito‚Äù,
  edad:35
  }
'''
Las claves de los documentos:
  * No pueden ser nulas.
  * No pueden contener los caracteres . (punto) y $ (d√≥lar).
  * Puede contener cualquiera de los dem√°s caracteres UTF-8 existentes.
  * Son case-sensitive (sensible a may√∫sculas y min√∫sculas), por lo que las claves ‚Äúnombre‚Äù y ‚ÄúNombre‚Äù son diferentes, y por tanto consideradas como campos diferentes.
  * Las claves dentro de un mismo documento deben ser √∫nicas, no pueden duplicarse. As√≠ por ejemplo el siguiente documento no es v√°lido por tener dos veces la clave nota.</p>
<p>'''jon
  {
  nombre:‚ÄùJose Antonio‚Äù,
  nota:8.9,
  nota:7.2 
  }
  '''</p>
<p>Cada documento en Mongo debe tener <strong>obligatoriamente</strong> un campo _id con valor √∫nico y que actuar√° como identificador √∫nico del documento. Es tan necesario este campo que cuando se guarda un documento sin especificarlo, Mongo autom√°ticamente le asigna uno del tipo ObjectId.</p>
<p>==== 3.2.1.2. Colecciones </p>
<p>Una colecci√≥n es un grupo de documentos, es lo an√°logo a las tablas en el modelo relacional.
Las colecciones tienen esquemas din√°micos, lo que significa que los documentos dentro de una colecci√≥n pueden tener m√∫ltiples ‚Äúformas‚Äù. Por ejemplo, los siguientes documentos podr√≠an guardarse en la misma colecci√≥n, a pesar de tener diferentes campos, y diferentes tipos de dato.</p>
<p active:true="active:true" type:6_="type:6," username::_pepito_="username::‚Äùpepito‚Äù,">{ nombre:‚ÄùJose Antonio‚Äù, edad:35 }</p>
<p>Hay algunas restricciones respecto a nombre que una colecci√≥n puede tener:
  * La cadena vac√≠a (‚Äú‚Äù) no es un nombre v√°lido.
  * Lo puede contener el car√°cter null.
  * No se pueden crear colecciones cuyo nombre empiece por ‚Äúsystem.‚Äù, ya que es un prefijo reservado para colecciones internas.
  * No debe contener el car√°cter $ (d√≥lar).</p>
<p>=== 3.2.2. Operaciones b√°sicas
==== 3.2.2.1. Inserci√≥n ===</p>
<p>Para insertar un documento en una colecci√≥n, utilice el m√©todo:
  db.alumno.insert( {"name":"Antonio Cuenca"})</p>
<p>El comando ha a√±adido autom√°ticamente el campo _id de tipo ObjectId, ya que como hemos explicado, todo documento debe tener un identificador √∫nico.
Pero el uso del tipo ObjectId para el campo _id no es obligatorio, podemos utilizar cualquier valor, siempre y cuando garanticemos su unicidad. A continuaci√≥n insertamos una nueva alumna, especificando que su _id es el n√∫mero 10 (tipo Long).
  db.alumno.insert( { _id:NumberLong(10), name:"Raquel",apellidos:"Gutierrez Garcia"} )</p>
<p>Si queremos insertar m√∫ltiples documentos,podemos hacer la inserci√≥n m√°s r√°pida utilizando batch inserts, que permiten insertar en bloque un array de documentos a la colecci√≥n. Esto se consigue con solo pasar un array de objetos al comando insert.
  db.numerosprimos.insert(
  [{_id:2},{_id:3},{_id:5},{_id:7},{_id:11},{_id:13},{_id:17},{_id:19},
  {_id:23}] )</p>
<p>==== 3.2.2.2. Borrado 
Vaya con cuidado, eliminar colecciones completas es muy sencillo en Mongo. Esto borrar√° todo, tanto la colecci√≥n como meta propiedades asociadas a ella o
√≠ndices creados sobre campos.
  db.alumno.drop()
Por otra parte, para eliminar solo documentos de una colecci√≥n, tenemos el comando remove, que recibe como par√°metro el criterio de borrado en forma de documento JSON. En ese caso, solo los documentos que cumplen el criterio se eliminar√°n de la colecci√≥n.
  db.numerosprimos.remove( {_id:23} )</p>
<p>==== 3.2.2.3. Modificaci√≥n 
Para modificar un documento se utiliza el m√©todo update. Este m√©todo recibe dos par√°metros, el primero es el criterio de actualizaci√≥n, y el segundo el modificador, que describe los cambios que deben realizarse.</p>
<p>Tenemos dos tipos de actualizaci√≥n. El cambio completo del documento o reemplazo y la modificaci√≥n de algunos elementos del documento</p>
<p>Veamos un ejemplo de reemplazo. Creamos un elemento con los siguientes datos:<br />
  db.usuarios.insert({name:"jose",friends:32,enemies:2})</p>
<p>El documento seria:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "friends" : 32,
    "enemies" : 2
  }  </p>
<p>Ahora lo reemplazamos:
  db.usuarios.update( {name:"jose"}, {name:"jose",relationships: {friends:32,enemies:2}})</p>
<p>Y quedar√≠a as√≠:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "relationships" : {
       "friends" : 32,
       "enemies" : 2
    }
  }</p>
<p>Si lo que queremos es modificar algunos campos utilizaremos el insert, pero con modificadores. Ve√°moslos:</p>
<p><strong>$set</strong></p>
<p>Asigna el valor a un campo. Si el campo todav√≠a no existe en el documento lo crear√°. Se utiliza en el segundo par√°metro que se le pasa al comando update.
  db.alumno.insert( { name:"Arturo", apellidos:"Leon Zapata" })
  db.alumno.update( {name:"Arturo"}, { $set: {edad:17} })</p>
<p>Podemos darle valor a varios campos a la vez, simplemente informando los pares clave:valor separados por coma. En este ejemplo damos valor a tres campos diferentes con un solo comando.
  db.alumno.update( {name:"Arturo"}, { $set:{nota:8.2,orden:12,actitud:"positiva"} })</p>
<p><strong>$unset</strong></p>
<p>Para eliminar cualquier campo de uno o varios documentos lo hacemos tambi√©n con el comando update pero con el modificador $unset.
En MongoDB es habitual utilizar los valores 1 y -1 para indicar verdadero y falso respectivamente. En este caso, al especificar valor 1 estamos diciendo que la
clave entra dentro del conjunto de campos en los que queremos aplicar el $unset.
De esta forma, si queremos eliminar el campo ‚Äúedad‚Äù del documento que guarda la informaci√≥n del alumno ‚ÄúArturo‚Äù, lo har√≠amos as√≠.
  db.alumno.update({name:"Arturo"},{$unset:{edad:1}})</p>
<p><strong>$inc</strong></p>
<p>Este modificador puede utilizarse para incrementar o decrementar el valor num√©rico de una clave existente o para crear una nueva si no existe.
  db.alumno.update({name:"Arturo"},{$inc:{puntuacion:2}})</p>
<p>Otros operadores que podemos utilizar de forma similar son <strong>$mul, $min, $max y $currentDate</strong>.
  db.alumno.update({name:"Arturo"},{$min:{puntuacion:3}})
El ejmplo de arriba modifica la puntuacion si esta es menor que3</p>
<p>Ahora vamos a ver modificadores de arrays.
<strong>$push</strong>
Se utiliza para a√±adir elementos a un array. Si el array no existe lo crea con los elementos indicados en el push, y si ya existe los a√±ade al final del array.
  db.alumno.insert({name:"Sofia", apellidos:"Alarcon Sevilla"})
  db.alumno.update({name:"Sofia"},{$push:{"asignaturas":{name:"Matematicas", nota:9.1}}})</p>
<p><strong>$pull</strong></p>
<p>Hay varias formas de eliminar elementos de un array. Cuando queremos borrar elementos basados en alg√∫n criterio, el modificador adecuado es $pull.
Partimos de un array y borraremos elementos
  db.lists.insert({"todo": ["lavar platos", "colada", "tender"]})
Para eliminar la colada har√≠amos.
  db.lists.update({},{$pull:{"todo":"colada"}})</p>
<p><strong>$pop</strong></p>
<p>Para eliminar el primer o √∫ltimo elemento del array.
Para eliminar el √∫ltimo elemento del array:
  db.lists.update({},{$pop:{todo:1}})
Para eliminar el prtimer elemento del array:
  db.lists.update({},{$pop:{todo:-1}})</p>
<p><strong>Upserts</strong></p>
<p>Un upsert es un tipo de update espcial. Si no se encuentra ning√∫n documento que haga matching con el criterio del update, entonces se crear√° un nuevo documento combinando el criterio y lo que se quiere actualizar. Si se encuentra un documento que haga matching se actualizar√° normalmente.
Para decirle a MongoDB que queremos hacer un upsert, solo hay que pasar al comando update un tercer par√°metro, con valor true. Esto significa que el update se comportar√° como hemos explicado que lo hace el upsert. 
  update({...},{...},true)
  db.alumno.update({name:"Sofia"},{$set:{apellidos:"Alarcon Revilla"}},true)</p>
<p><strong>Multiples Documentos</strong></p>
<p>Para modificar m√∫ltiples documentos, en el tercer par√°metro del update indicaremos {multi: true}. 
  db.books.update({lang:"en"},{$inc: {price: 50.00}}, {multi:true})</p>
<p>==== Consultas ====
El m√©todo find es el que se utiliza para hacer queries en Mongo. Es el equivalente al comando select en el modelo relacional. Al consultar una colecci√≥n, Mongo nos
devolver√° un subconjunto de documentos, que variar√° desde el conjunto vaci√≥ hasta la colecci√≥n completa.
Find tiene varios par√°metros de entrada, el primero de ellos especifica los documentos que queremos recuperar, esto es, el criterio de b√∫squeda.
  db.coleccion1.find({ clave1:valor1 })
La funci√≥n anterior nos devolver√≠a documentos de la colecci√≥n coleccion1 cuyo campo clave1 tenga un valor igual a valor1.</p>
<p>El valor por defecto para este primer par√°metro es {}, que significa ‚Äúcualquier documento‚Äù. Por tanto una query como db.coleccion1.find({ }) devolver√° todos los documentos de la colecci√≥n coleccion1. Como es el valor por defecto para el criterio de la consulta es equivalente hacer find({ }) y find( ).</p>
<p>db.alumno.find({edad:17})
  db.alumno.find({name:"Antonio"})</p>
<p>Igual que en SQL podemos especificar los campos que queremos recuperar (select campo1, campo2, campo3 from tabla ... ), podemos hacerlo tambi√©n en Mongo. Para ello solo tenemos que pasar un segundo par√°metro al m√©todo find, en el que decimos los que queremos.
  db.coleccion1.find({ },{ clave3:1, clave4:1 })
Los campos que queremos que sean d====== 2. No SQL ======
===== Bases de datos No SQL =====
===== MongoDB =====
==== Conceptos B√°sicos ====
Los elementos de MongoDB son:
  * <strong>Bases de Datos</strong>:
    * Act√∫a cada una como un contenedor de alto nivel
  * <strong>Colecciones</strong>:
    * Una base de datos tendr√° 0 o m√°s colecciones. 
    * Una colecci√≥n es muy similar a lo que entendemos como tabla dentro de un SGDB.
  * <strong>Documentos</strong>:
    * Las colecciones contiene 0 o m√°s documentos, por lo que es similar a una fila o registro de un RDMS.</p>
<p>=== Documentos ===</p>
<p>El coraz√≥n de MongoDB es el documento, un conjunto ordenado de claves con valores asociados. Su representaci√≥n como hemos nombrado en el tema anterior es en JSON, un formato muy intuitivo y que no pensamos que requiera mayor explicaci√≥n. Este podr√≠a ser un ejemplo sencillo de un documento que guarda el nombre, apellidos y dedad de una persona. A la izquierda de los dos puntos el nombre del campo y a la derecha el valor.</p>
<p>{
  nombre:‚ÄùJose Antonio‚Äù,
  apellidos:‚ÄùGuillem Benedito‚Äù,
  edad:35
  }</p>
<p>Las claves de los documentos:
  * No pueden ser nulas.
  * No pueden contener los caracteres . (punto) y $ (d√≥lar).
  * Puede contener cualquiera de los dem√°s caracteres UTF-8 existentes.
  * Son case-sensitive (sensible a may√∫sculas y min√∫sculas), por lo que las claves ‚Äúnombre‚Äù y ‚ÄúNombre‚Äù son diferentes, y por tanto consideradas como campos diferentes.
  * Las claves dentro de un mismo documento deben ser √∫nicas, no pueden duplicarse. As√≠ por ejemplo el siguiente documento no es v√°lido por tener dos veces la clave nota.</p>
<p>'''json
  {
  nombre:‚ÄùJose Antonio‚Äù,
  nota:8.9,
  nota:7.2 
  }
  '''</p>
<p>Cada documento en Mongo debe tener <strong>obligatoriamente</strong> un campo _id con valor √∫nico y que actuar√° como identificador √∫nico del documento. Es tan necesario este campo que cuando se guarda un documento sin especificarlo, Mongo autom√°ticamente le asigna uno del tipo ObjectId.</p>
<p>=== Colecciones ===</p>
<p>Una colecci√≥n es un grupo de documentos, es lo an√°logo a las tablas en el modelo relacional.
Las colecciones tienen esquemas din√°micos, lo que significa que los documentos dentro de una colecci√≥n pueden tener m√∫ltiples ‚Äúformas‚Äù. Por ejemplo, los siguientes documentos podr√≠an guardarse en la misma colecci√≥n, a pesar de tener diferentes campos, y diferentes tipos de dato.</p>
<p active:true="active:true" type:6_="type:6," username::_pepito_="username::‚Äùpepito‚Äù,">{ nombre:‚ÄùJose Antonio‚Äù, edad:35 }</p>
<p>Hay algunas restricciones respecto a nombre que una colecci√≥n puede tener:
  * La cadena vac√≠a (‚Äú‚Äù) no es un nombre v√°lido.
  * Lo puede contener el car√°cter null.
  * No se pueden crear colecciones cuyo nombre empiece por ‚Äúsystem.‚Äù, ya que es un prefijo reservado para colecciones internas.
  * No debe contener el car√°cter $ (d√≥lar).</p>
<p>==== Operaciones b√°sicas ====
=== Inserci√≥n ===</p>
<p>Para insertar un documento en una colecci√≥n, utilice el m√©todo:
  db.alumno.insert( {"name":"Antonio Cuenca"})</p>
<p>El comando ha a√±adido autom√°ticamente el campo _id de tipo ObjectId, ya que como hemos explicado, todo documento debe tener un identificador √∫nico.
Pero el uso del tipo ObjectId para el campo _id no es obligatorio, podemos utilizar cualquier valor, siempre y cuando garanticemos su unicidad. A continuaci√≥n insertamos una nueva alumna, especificando que su _id es el n√∫mero 10 (tipo Long).
  db.alumno.insert( { _id:NumberLong(10), name:"Raquel",apellidos:"Gutierrez Garcia"} )</p>
<p>Si queremos insertar m√∫ltiples documentos,podemos hacer la inserci√≥n m√°s r√°pida utilizando batch inserts, que permiten insertar en bloque un array de documentos a la colecci√≥n. Esto se consigue con solo pasar un array de objetos al comando insert.
  db.numerosprimos.insert(
  [{_id:2},{_id:3},{_id:5},{_id:7},{_id:11},{_id:13},{_id:17},{_id:19},
  {_id:23}] )</p>
<p>=== Borrado ===
Vaya con cuidado, eliminar colecciones completas es muy sencillo en Mongo. Esto borrar√° todo, tanto la colecci√≥n como meta propiedades asociadas a ella o
√≠ndices creados sobre campos.
  db.alumno.drop()
Por otra parte, para eliminar solo documentos de una colecci√≥n, tenemos el comando remove, que recibe como par√°metro el criterio de borrado en forma de documento JSON. En ese caso, solo los documentos que cumplen el criterio se eliminar√°n de la colecci√≥n.
  db.numerosprimos.remove( {_id:23} )</p>
<p>=== Modificaci√≥n ===
Para modificar un documento se utiliza el m√©todo update. Este m√©todo recibe dos par√°metros, el primero es el criterio de actualizaci√≥n, y el segundo el modificador, que describe los cambios que deben realizarse.</p>
<p>Tenemos dos tipos de actualizaci√≥n. El cambio completo del documento o reemplazo y la modificaci√≥n de algunos elementos del documento</p>
<p>Veamos un ejemplo de reemplazo. Creamos un elemento con los siguientes datos:<br />
  db.usuarios.insert({name:"jose",friends:32,enemies:2})</p>
<p>El documento seria:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "friends" : 32,
    "enemies" : 2
  }  </p>
<p>Ahora lo reemplazamos:
  db.usuarios.update( {name:"jose"}, {name:"jose",relationships: {friends:32,enemies:2}})</p>
<p>Y quedar√≠a as√≠:
  {
    "_id" : ObjectId("5386c4fdd73aa9d8f663acda"),
    "name" : "jose",
    "relationships" : {
       "friends" : 32,
       "enemies" : 2
    }
  }</p>
<p>Si lo que queremos es modificar algunos campos utilizaremos el insert, pero con modificadores. Ve√°moslos:</p>
<p><strong>$set</strong></p>
<p>Asigna el valor a un campo. Si el campo todav√≠a no existe en el documento lo crear√°. Se utiliza en el segundo par√°metro que se le pasa al comando update.
  db.alumno.insert( { name:"Arturo", apellidos:"Leon Zapata" })
  db.alumno.update( {name:"Arturo"}, { $set: {edad:17} })</p>
<p>Podemos darle valor a varios campos a la vez, simplemente informando los pares clave:valor separados por coma. En este ejemplo damos valor a tres campos diferentes con un solo comando.
  db.alumno.update( {name:"Arturo"}, { $set:{nota:8.2,orden:12,actitud:"positiva"} })</p>
<p><strong>$unset</strong></p>
<p>Para eliminar cualquier campo de uno o varios documentos lo hacemos tambi√©n con el comando update pero con el modificador $unset.
En MongoDB es habitual utilizar los valores 1 y -1 para indicar verdadero y falso respectivamente. En este caso, al especificar valor 1 estamos diciendo que la
clave entra dentro del conjunto de campos en los que queremos aplicar el $unset.
De esta forma, si queremos eliminar el campo ‚Äúedad‚Äù del documento que guarda la informaci√≥n del alumno ‚ÄúArturo‚Äù, lo har√≠amos as√≠.
  db.alumno.update({name:"Arturo"},{$unset:{edad:1}})</p>
<p><strong>$inc</strong></p>
<p>Este modificador puede utilizarse para incrementar o decrementar el valor num√©rico de una clave existente o para crear una nueva si no existe.
  db.alumno.update({name:"Arturo"},{$inc:{puntuacion:2}})</p>
<p>Otros operadores que podemos utilizar de forma similar son <strong>$mul, $min, $max y $currentDate</strong>.
  db.alumno.update({name:"Arturo"},{$min:{puntuacion:3}})
El ejmplo de arriba modifica la puntuacion si esta es menor que3</p>
<p>Ahora vamos a ver modificadores de arrays.
<strong>$push</strong>
Se utiliza para a√±adir elementos a un array. Si el array no existe lo crea con los elementos indicados en el push, y si ya existe los a√±ade al final del array.
  db.alumno.insert({name:"Sofia", apellidos:"Alarcon Sevilla"})
  db.alumno.update({name:"Sofia"},{$push:{"asignaturas":{name:"Matematicas", nota:9.1}}})</p>
<p><strong>$pull</strong></p>
<p>Hay varias formas de eliminar elementos de un array. Cuando queremos borrar elementos basados en alg√∫n criterio, el modificador adecuado es $pull.
Partimos de un array y borraremos elementos
  db.lists.insert({"todo": ["lavar platos", "colada", "tender"]})
Para eliminar la colada har√≠amos.
  db.lists.update({},{$pull:{"todo":"colada"}})</p>
<p><strong>$pop</strong></p>
<p>Para eliminar el primer o √∫ltimo elemento del array.
Para eliminar el √∫ltimo elemento del array:
  db.lists.update({},{$pop:{todo:1}})
Para eliminar el prtimer elemento del array:
  db.lists.update({},{$pop:{todo:-1}})</p>
<p><strong>Upserts</strong></p>
<p>Un upsert es un tipo de update espcial. Si no se encuentra ning√∫n documento que haga matching con el criterio del update, entonces se crear√° un nuevo documento combinando el criterio y lo que se quiere actualizar. Si se encuentra un documento que haga matching se actualizar√° normalmente.
Para decirle a MongoDB que queremos hacer un upsert, solo hay que pasar al comando update un tercer par√°metro, con valor true. Esto significa que el update se comportar√° como hemos explicado que lo hace el upsert. 
  update({...},{...},true)
  db.alumno.update({name:"Sofia"},{$set:{apellidos:"Alarcon Revilla"}},true)</p>
<p><strong>Multiples Documentos</strong></p>
<p>Para modificar m√∫ltiples documentos, en el tercer par√°metro del update indicaremos {multi: true}. 
  db.books.update({lang:"en"},{$inc: {price: 50.00}}, {multi:true})</p>
<p>==== Consultas ====
El m√©todo find es el que se utiliza para hacer queries en Mongo. Es el equivalente al comando select en el modelo relacional. Al consultar una colecci√≥n, Mongo nos
devolver√° un subconjunto de documentos, que variar√° desde el conjunto vaci√≥ hasta la colecci√≥n completa.
Find tiene varios par√°metros de entrada, el primero de ellos especifica los documentos que queremos recuperar, esto es, el criterio de b√∫squeda.
  db.coleccion1.find({ clave1:valor1 })
La funci√≥n anterior nos devolver√≠a documentos de la colecci√≥n coleccion1 cuyo campo clave1 tenga un valor igual a valor1.</p>
<p>El valor por defecto para este primer par√°metro es {}, que significa ‚Äúcualquier documento‚Äù. Por tanto una query como db.coleccion1.find({ }) devolver√° todos los documentos de la colecci√≥n coleccion1. Como es el valor por defecto para el criterio de la consulta es equivalente hacer find({ }) y find( ).</p>
<p>db.alumno.find({edad:17})
  db.alumno.find({name:"Antonio"})</p>
<p>Igual que en SQL podemos especificar los campos que queremos recuperar (select campo1, campo2, campo3 from tabla ... ), podemos hacerlo tambi√©n en Mongo. Para ello solo tenemos que pasar un segundo par√°metro al m√©todo find, en el que decimos los que queremos.
  db.coleccion1.find({ },{ clave3:1, clave4:1 })
Los campos que queremos que sean devueltos les pondremos el valor 1. El campo _id siempre se devuelve. Tambi√©n podemos especificar los campos que no queremos que sean devueltos, en este caso como valor para cada una de esos campos, pondremos cero. El resultado ser√° que se devolver√°n el resto de documentos.
  db.coleccion1.find({ },{ clave3:0, clave4:0 })</p>
<p>=== Operadores de comparaci√≥n ===
MongoDB permite utilizar los siguientes operadores de comparaci√≥n:
  * <strong>$lt</strong> (less than), se corresponde con la condici√≥n &lt; (menor estricto).
  * <strong>$lte</strong> (less than or equal), se corresponde con la condici√≥n &lt;= (menor o igual).
  * <strong>$gt</strong> (greather than), se corresponde con la condici√≥n &gt; (mayor estricto).
  * <strong>$gte</strong> (greather than or equal), se corresponde con la condici√≥n &gt;= (mayor o igual).</p>
<p>clave: { $operador: valor }</p>
<p>As√≠ si por ejemplo queremos recuperar los libros con un precio mayor que 10 lo har√≠amos utilizando el operador $gt sobre el campo precio:
  db.libro.find({"precio":{$gt:10}},{titulo:1,precio:1})</p>
<p>=== Operadores l√≥gicos ===</p>
<p><strong>$in</strong>
  clave: { $in: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave est√© entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$in:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$nin</strong>
  clave: { $nin: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave NO est√© entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$nin:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$or</strong>
  $or: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que est√©n en stock (enstock:false) o que tengan editorial (editorial:null).
  db.libro.find({$or:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$nor</strong>
  $nor: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que no est√©n en stock (enstock:false) o que no tengan editorial (editorial:null).
  db.libro.find({$nor:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$not</strong></p>
<p>$not es lo que se conoce como un metacondicional, que son opeadores que pueden aplicarse por encima de cualquier otro criterio. Su sintaxis es sencilla, solo hay que ponerlo ‚Äúfuera‚Äù de aquello que queremos negar.
  $not: { criterio }
Y as√≠ directamente podemos recuperar por ejemplo, documentos que no tengan 480 paginas.
  db.libro.find( { paginas: {$not: { $eq:480 } } },{titulo:1,paginas:1} )</p>
<p><strong>$exist</strong></p>
<p>El operador $exists se utiliza para comprobar los documentos que tienen informado o no un campo determinado. Su sintaxis es la siguiente:
  clave: { $exists: boolean}
Donde boolean puede ser true o false. En el caso de true devuelve documentos que tienen informado un campo, aunque su valor sea null. Este operador es √∫til porque debido a la ausencia de definici√≥n de esquema de datos de mongo, cada documento de una misma colecci√≥n puede tener los campos que requiera, y al hacer consultas puede que no nos devuelva ciertos documentos bien porque no entra dentro de los valores exigidos, bien porque el campo no est√° definido.
Veamos un ejemplo con dos comandos find donde utilizamos el operador $exists con ambos valores.
  db.libro.find({paginas:{$exists:true}},{paginas:1})</p>
<p><note important><strong>null</strong> tiene un comportamiento un poco extra√±o, ya que hace matching en los siguientes casos:
  * Con valores que almacenan null, por ejemplo ‚Äúy‚Äù : null
  * Con campos que no existen en un documento. Si por ejemplo el documentoA no tiene informado el campo x, una b√∫squeda por { x:null } s√≠ que se encontrar√≠a.</p>
<p></note></p>
<p><strong>Expresiones regulares</strong></p>
<p>MongoDB incluye el trabajo con expresiones regulares de forma nativa.
Ejemplo: Recuperamos los libros del autor Posteguillo, sin preocuparnos por may√∫sculas y min√∫sculas, har√≠amos esta consulta.
  db.libro.find({autor:/posteguillo/i},{titulo:1,autor:1}).pretty()</p>
<p><strong>B√∫squeda de texto</strong></p>
<p>En MongoDB, podemos realizar b√∫squedas de texto usando el √≠ndice de texto y el operador $text. Pasos:</p>
<p>Primero se crea un √≠ndice de texto en los  campos para realizar la b√∫squeda de  texto. </p>
<p>db.books.createIndex({"title":"text"})   //---  Un campo//
  db.books.createIndex({"title":"text","autor":"text"}) //---  Varios campos//</p>
<p>Luego se realiza la busqueda con $text. La expresi√≥n $text tiene la siguiente sintaxis:
  {
    $text:
    {
        $search: <string>,
        $lenguage: <string>, Opcional
        $caseSensitive: <boolean>,Opcional
        $diacriticSensitive: <boolean> Opcional
    }
  }</p>
<p>Ejemplos:</p>
<p>db.books.find({
           $text:{$search:"la",$caseSensitive:true}
           })</p>
<p>db.books.find({
           $text:{$search:"la -Biblia"}    //--- Busca "la" pero no "Biblia"//
          }) </p>
<p>==== Consultas con Arrays ====</p>
<p>Creamos una colecci√≥n para ver los ejemplos
  db.comida.insert({fruta:["manzana","platano","pera"]})</p>
<p>Para buscar documentos que tengan un elemento concreto dentro del array, es tan simple como poner el nombre del array y el valor que queremos encontrar.
  db.comida.findOne({fruta:"pera"})</p>
<p>Podemos utilizar cualquiera de los operadores aprendidos hasta el momento, como por ejemplo $in, para recuperar documentos que tengan alguno de los
valores especificados.
  db.comida.findOne({fruta: { $in:["pera","platano","melocoton"] }})</p>
<p>Si necesita recuperar arrays que contengan m√°s de un elemento, puede utilizar el operador $all, que permite especificar una lista de elementos.
Modificamos la colecci√≥n para ver unos ejemplos
  db.comida.drop()
  db.comida.insert({_id:1, fruta:["manzana","platano","melocoton"]})
  db.comida.insert({_id:2, fruta:["manzana","kiwi","naranja"]})
  db.comida.insert({_id:3, fruta:["cerezas","platano","manzana"]})</p>
<p>Si ahora queremos documentos que tengan los elementos platano y manzana, lo haremos con $all de esta forma.
  db.comida.find({fruta: { $all:["platano","manzana"]}})</p>
<p>Para recuperar documentos que tengan un valor concreto en cierto √≠ndice delarray, se consigue poniendo dicho √≠ndice (empezando desde cero) tras un punto
del array. Es decir: fruta.0 es el primer elemento del array.
  db.comida.find({"fruta.0":"cerezas"})</p>
<p><strong>$size</strong></p>
<p>Un condicional √∫til para las consultas contra arrays es $size, que permite recuperar arrays que tienen un determinado tama√±o.
La siguiente consulta muestra los documentos que tenga 2 frutas.
  db.comida.find({fruta:{$size:2}})</p>
<p><strong>$slice</strong></p>
<p>El operador $slice se utiliza para devolver un subconjunto de los elementos delarray. No influye en el criterio de b√∫squeda, solo es para especificar a mongo lo
que queremos que nos devuelva. Su sintaxis es la siguiente.
  clave: { $slice: x}
Donde seg√∫n x:
  * x es un entero positivo (p.ej 10), devuelve los primeros x elementos del array clave.
  * x es un entero negativo (p.ej -10), devuelve los √∫ltimos x elementos del array clave.
  * x es un array (p.ej [2,4], devuelve los elementos desde el 2 al 4, ambos incluidos.</p>
<p>Ejemplos:
  db.comida.find({},{fruta:{$slice:2}})
  db.comida.find({},{fruta:{$slice:-2}})
  db.comida.find({},{fruta:{$slice:[1,3]}})</p>
<p><strong>Conjuntos de valores</strong></p>
<p>Si queremos obtener todos los diferentes valores que existen en un campo, utilizaremos el m√©todo distinct
  db.grades.distinct('type')</p>
<p><strong>Contar valores</strong></p>
<p>Para contar el n√∫mero de documentos, en vez de find usaremos el m√©todo count. Por ejemplo:
  db.grades.count({type:"exam"})
  db.grades.find({type:"exam"}).count() 
  db.grades.count({type:"essay", score:{$gt:90}})
==== Documentos embebidos ====</p>
<p>Para hacer queries contra campos de documentos embebidos dentro de otros documentos, solamente hay que poner la ‚Äúruta‚Äù completa de claves separada por puntos. Es decir, si tenemos por ejemplo una estructura como esta para los libros.
  db.libro.save({
          "_id":"9788408117117",
          "titulo":"Circo M√°ximo",
          "autor": {
                    nombre:"Santiago",
                    apellidos:"Posteguillo G√≥mez",
                    nacimiento: {
                                 anyo:1967,
                                 ciudad:"Valencia"
                   }
          },
         "editorial":"Planeta",
         "enstock":true,
         "paginas":1100,
         "precio":21.75
  })</p>
<p>Podemos lanzar queries directamente contra los documentos embebidos, autor y nacimiento de esta forma. Para re
  db.libro.findOne({"autor.nombre":"Santiago"})</p>
<p>El find anterior recuperar√° el primer documento donde el campo nombre, del campo autor sea ‚ÄúSantiago‚Äù.</p>
<p>db.libro.findOne({"autor.nacimiento.anyo":{$gt:1965}})
El find anterior recuperar√° el primer documento donde el campo anyo, del campo nacimiento, del campo autor sea mayor que 1965.
==== Cursores ====
La base de datos devuelve resultados para find utilizando cursores, que realmente es un puntero a los resultados de una query, no los resultados en si
mismos. Los clientes integrados con Mongo, iteran sobre los cursores para recuperar los resultados, y ofrecen un conjunto de funcionalidades como limitar
el n√∫mero de resultados, saltar para no tener que recuperar obligatoriamente los primeros, ordenarlos, etc.</p>
<p>Las opciones de query m√°s comunes son limitar el n√∫mero de resultados, saltar un n√∫mero de resultados, y ordenarlos. Todas estas opciones deben especificarse en la propia query al sistema.</p>
<p>Para fijar un l√≠mite, debe concatenar la funci√≥n <strong>limit</strong> tras la funci√≥n find. Por ejemplo, para solo recuperar los primeros tres libros almacenados, use esto:
  db.libro.find({},{titulo:1}).limit(3)</p>
<p>La funci√≥n <strong>skip</strong> para ‚Äúsaltar‚Äù algunos resultados, funciona de forma similar a limit, concaten√°ndola tras find. Con el siguiente skip(3) saltamos los primeros
tres t√≠tulos, y el cursor empezar√° a devolver a partir del cuarto.
 db.libro.find({},{titulo:1}).skip(3)</p>
<p>La funci√≥n <strong>sort</strong> sirve para ordenar los resultados que se devuelven. Recibe un objeto json con las claves y un valor 1 (para ordenaci√≥n ascendente) o -1 (para ordenaci√≥n descendente).
  db.libro.find({},{titulo:1,precio:1,paginas:1}).sort({precio:1,paginas:-1})</p>
<p>Estas tres funciones, limit, skip y sort, pueden combinarse como se quiera para recuperar exactamente lo que queramos.
  db.libro.find({},{titulo:1,precio:1,paginas:1}).limit(3).skip(2).sort({precio:1, paginas:-1}).pretty()</p>
<p>==== Agregaci√≥n ====
Una vez tenemos datos almacenados en MongoDB, queremos hacer m√°s que solamente recuperarlos, queremos analizarlos de diversas formas interesantes. 
Esto lo conseguimos con la funci√≥n de agregaci√≥n que Mongo ofrece.
La agregaci√≥n nos permite transformar y combinar documentos en una colecci√≥n. B√°sicamente, se construye un pipeline (secuencia de comandos) 
que procesan un conjunto de documentos a trav√©s de varios ‚Äúbloques‚Äù: filtrado, proyecciones, agrupaciones, ordenaci√≥n, limitaci√≥n y skipping.</p>
<p>Por ejemplo, si de la colecci√≥n de libros de ejemplo quisi√©ramos saber los tres autores con m√°s libros escritos, crear√≠amos un pipeline con los siguientes pasos:
  * Proyectar√≠amos el autor de cada libro.0
  * Agrupar√≠amos los autores por nombre, contando el n√∫mero de ocurrencias.
  * Ordenar√≠amos los autores por dicho n√∫mero de ocurrencias, descendentemente.
  * Limitar√≠amos el resultado a los primeros tres.</p>
<p>Cada uno de estos pasos se corresponde con un operador de agregaci√≥n</p>
<ol>
<li>
<p>{‚Äú<strong>$project‚Äù : { ‚Äúautor‚Äù : 1 }}</strong> Esto ‚Äúproyecta/extrae‚Äù el autor de cada documento. La sintaxis es similar al selector  de  campos  utilizado  con  find  (el  segundo  par√°metro), 
especificando  ‚Äúnombrecampo‚Äù:  1  para  incluir  o  ‚Äúnombrecampo‚Äù:0  para excluir.
Despu√©s de esta operaci√≥n, cada documento de los  resultados es algo as√≠: 
{‚Äú_id‚Äù:id,  ‚Äúautor‚Äù:‚Äùnombre  de  autor‚Äù}.  Estos  resultados  solo  existen  en memoria, no se escribir√°n nunca a disco</p>
</li>
<li>
<p __id_:_nombre="‚Äú_id‚Äù:‚Äùnombre" _count_:="‚Äúcount‚Äù:" autor_="autor‚Äù," de="de" numeroDeLibros="numeroDeLibros"><strong>{‚Äú$group‚Äù : { ‚Äú_id‚Äù:‚Äù$autor‚Äù, ‚Äúcount‚Äù: {‚Äú$sum‚Äù:1}}}</strong>  Eso agrupa por autores e incrementa ‚Äúcount‚Äù para cada documento en los que el autor aparece.
Primero especificamos el campo por el que queremos agrupar, que es ‚Äúautor‚Äù. Esto lo indicamos con el ‚Äú_id‚Äù:‚Äù$autor‚Äù. Podr√≠amos entenderlo 
como: tras el Group habr√° un documento resultado para cada autor, por lo que ‚Äúautor‚Äù se convertir√° en el identificador √∫nico (‚Äú_id‚Äù).
El segundo campo significa a√±adir 1 al campo ‚Äúcount‚Äù para cada documento en el grupo. F√≠jese  que los documentos de entrada (libro) no tienen el 
campo ‚Äúcount‚Äù, es un nuevo campo creado por el ‚Äú$group‚Äù.
Al final de este paso, cada documento resultado es algo como: </p>
</li>
<li>
<p><strong>{‚Äú$sort‚Äù : {‚Äúcount‚Äù : -1}}</strong> Esto reordena los resultados por el valor del campo ‚Äúcount‚Äù 
descendentemente (-1). En caso de ascendente ser√≠a ‚Äúcount‚Äù:1.</p>
</li>
<li>
<p><strong>{‚Äú$limit‚Äù : 3}</strong>  Limita el n√∫mero de resultados a los primeros tres.</p>
</li>
</ol>
<p>Veamos todo esto con m√°s detalle y partiendo de un ejemplo con una colecci√≥n de libros</p>
<p 1="1" :=":" Casanovas_="Casanovas&quot;," _Anna="&quot;Anna" __id_="&quot;_id&quot;" _count_="&quot;count&quot;"><sxh php>
db.libro.aggregate({$project:{autor:1}},
                   {$group:{_id:"$autor",count:{$sum:1}}},
                   {$sort:{count:-1}},{$limit:3}
                  )
</sxh>
  { "_id" : "Santiago Posteguillo", "count" : 3 }
  { "_id" : "George R.R. Martin", "count" : 2 }</p>
<p>=== Operaciones Pipeline ===
Cada operador recibe un conjunto de documentos, hace alg√∫n tipo de transformaci√≥n sobre ellos, y despu√©s pasa el resultado de la transformaci√≥n. 
Esto es lo que se conoce como pipeline.</p>
<p>{{ :clase:iabd:bda:mongodb.png?600 |}}</p>
<p>== Operador $match ==</p>
<p>El operador $match filtra documentos de forma que podamos ejecutar una agregaci√≥n sobre un subconjunto de documentos.
$match puede utilizar todos los operadores para query estudiados ($gt, $lt, $in, etc).
Con el siguiente ejemplo, filtrar√≠amos solo aquellos libros con un precio mayor que 20, reduciendo el conjunto inicial de documentos y formando la entrada de 
los siguientes pasos del pipeline.
<sxh php>db.libro.aggregate({$match:{precio:{$gt:20}}})</sxh></p>
<p>Como hemos comentado, cualquiera de las condiciones estudiadas del find podemos utilizarlas con match. Como por ejemplo, los libros en stock. 
<sxh php>db.libro.aggregate({$match:{enstock:true}}) </sxh></p>
<p>== Operador $project ==
La ‚Äúproyecci√≥n‚Äù es mucho m√°s potente en el pipeline que en el lenguaje ‚Äúnormal‚Äù  de la query. $project nos permite extraer campos de subdocumentos, renombrar  campos, y realizar operaciones interesantes sobre ellos. 
La operaci√≥n m√°s sencilla de $project realiza una selecci√≥n simple de unos documentos de entrada, es decir, de los documentos de entrada con campos a, b, c y d, con $project decimos que nos quedamos √∫nicamente con a y c. Para incluir o excluir un campo, se utiliza la misma sintaxis que para el segundo argumento de una query, es decir ‚Äúnombrecampo‚Äù: 1 para incluir o ‚Äúnombrecampo‚Äù:0 para excluir. Por defecto, el campo ‚Äú_id‚Äù siempre se devuelve si existe en los documentos de entrada. Lo podemos eliminar por ejemplo utilizando $project de la siguiente forma, en la que devolver√≠amos todos los campos excepto ‚Äú_id‚Äù. {$project:{ ‚Äú_id‚Äù:0 }}  Con $project tambi√©n podemos renombrar el campo proyectado. </p>
<p>Por ejemplo si queremos devolver el campo ‚Äú_id‚Äù de los libros como ‚Äúisbn‚Äù har√≠amos esto. 
<sxh sql>
db.libro.aggregate({$project:{isbn:"$_id"}})
</sxh></p>
<p>La clave est√° en $_id, cuando ponemos el s√≠mbolo del d√≥lar ($) m√°s el nombre de un campo, nos estamos refiriendo al valor que tomar√° dicho campo para cada documento en el entorno de agregaci√≥n. Por tanto con $project: {‚Äúisbn‚Äù:‚Äù$_id‚Äù} estamos diciendo que proyectamos un nuevo campo isbn como el valor que tendr√° el campo _id en cada documento de entrada. 
Igualmente podr√≠amos haber renombrado cualquier otro campo, por ejemplo el campo ‚Äúenstock‚Äù como ‚Äúdisponible‚Äù. 
<sxh php>db.libro.aggregate({$project:{isbn:"$_id",disponible:"$enstock"}})</sxh></p>
<p>== Expresiones en el Pipeline ==</p>
<p>La operaciones m√°s simples en $project son inclusi√≥n, exclusi√≥n y nombres de campo (‚Äú$nombrecampo‚Äù).<br />
Aunque hay otras m√°s, mucho m√°s potentes. Podemos utilizar expresiones, que nos permiten combinar m√∫ltiples literales y variables en un valor √∫nico. </p>
<p><strong>Expresiones matem√°ticas</strong>. </p>
<p>Las expresiones matem√°ticas nos permiten manipular valores num√©ricos contra los que operar, y que normalmente se especifican en un array. </p>
<p>Esta es la sintaxis para cada operador matem√°tico. 
  * ‚Äú$add‚Äù: [ expr1, expr2, ... , exprN ]. Toma uno o mas expresiones y las suma. 
  * ‚Äú$substract‚Äù: [ expr1, expr2 ]. Resta la expr2 a la expr1. 
  * ‚Äú$multiply‚Äù: [ expr1, expr2, ..., exp√≥n ]. Toma una o m√°s expresiones y las multiplica. 
  * ‚Äú$divide‚Äù: [ expr1, expr2 ]. Divide la expr1 entre la expr2. 
  * ‚Äú$mod‚Äù: [ expr1, expr2 ]. Divide la expr1 entre la expr2 y devuelve el resto. </p>
<p><strong>Expresiones de fechas</strong>. </p>
<p>Muchas agregaciones son basadas en el tiempo. ¬øQu√© ocurri√≥ la semana pasada? ¬øY el mes pasado?. Es por esto que el entorno de agregaci√≥n  tiene  un  conjunto  de  expresiones  que  pueden  utilizarse  para  extraer informaci√≥n sobre fechas de una forma muy usable, son: ‚Äú$year‚Äù, ‚Äú$month‚Äù,‚Äú$week‚Äù, ‚Äú$dayOfMonth‚Äù, ‚Äú$dayOfWeek‚Äù, ‚Äú$dayOfYear‚Äù, ‚Äú$hour‚Äù, ‚Äú$minute‚Äù y ‚Äú$second‚Äù. </p>
<p>Con siguiente sentencia de agregaci√≥n vamos a recuperar tanto la fecha, como el a√±o de dicha fecha, gracias a la expresi√≥n ‚Äú$year‚Äù.</p>
<p><sxh php>db.libro.aggregate({$project:{fecha:1,year:{$year:"$fecha* }}})</sxh></p>
<p><strong>Expresiones de Strings</strong>.</p>
<p>Hay una pocas operaciones b√°sicas sobre cadenas de caracteres que tambi√©n podemos utilizar. Son 
estas: </p>
<p>‚Äú$substr‚Äù: [ expr, start, length ]. Devuelve el substring de la expresi√≥n expr, empezando en la posici√≥n start de la cadena y devolviendo desde ah√≠ un total de length caracteres. En el siguiente ejemplo proyectamos un campo inicio los primeros quince caracteres del campo t√≠tulo.<br />
<sxh php>db.libro.aggregate({$project: {inicio:{$substr: ["$titulo",0,15] }}})</sxh></p>
<p>‚Äú$concat‚Äù: [ expr1, expr2, ..., exprN ]. Devuelve un nuevo string resultado de la concatenaci√≥n de expr1, expr2 y as√≠ hasta exprN. En el siguiente ejemplo proyectamos un campo descripci√≥n en el que concatenamos el titulo, un gui√≥n, y el autor.<br />
<sxh php>db.libro.aggregate({$project:{descripcion:{$concat:["$titulo"," - ","$autor"]},_id:0}})</sxh></p>
<p>‚Äú$toLower‚Äù: expr. Devuelve un string en min√∫sculas. 
‚Äú$toUpper‚Äù: expr. Devuelve un string en may√∫sculas. </p>
<p><strong>Expresiones l√≥gicas</strong>.</p>
<p>Existen algunas operaciones l√≥gicas que podemos utilizar. Replanteamos el ejemplo anterior de la proyecci√≥n del campo ‚Äúbarato‚Äù utilizando  uno de estos comparadores.  </p>
<p><sxh php>db.libro.aggregate({$project:{barato:{$gt:[15,"$precio"]},precio:1} })</sxh></p>
<p>== Operador $sort ==
Podemos ordenar por cualquier campo o conjunto de campos utilizando la misma sintaxis que para las queries ‚Äúnormales‚Äù. Si tenemos que ordenar un n√∫mero de documentos muy elevado, es recomendable desde el punto de vista del rendimiento, que hagamos la ordenaci√≥n al principio del pipeline y adem√°s tengamos un √≠ndice por el conjunto de campos por los que ordenar. De otra forma, $sort puede ser lento y consumir mucha memoria. 
Se pueden utilizar tanto campos existentes como campos proyectados para ordenar. De esta forma podemos por ejemplo completar la agregraci√≥n en la que calcul√°bamos la media aritm√©tica del precio de los libros por autor, y ordenar los resultados por dicha media calculada ascendentemente. </p>
<p><sxh php>
db.libro.aggregate({$group:{_id:"$autor", media:{$avg:"$precio"}}},
                   {$sort:{media:1}}
                  )
</sxh></p>
<p>Para ordenar cada campo es valor 1, para ordenaci√≥n ascendente y -¬≠‚Äê1 para descendente. En el siguiente ejemplo ordenamos primero por precio descendente y despu√©s por p√°ginas ascendente.
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}}
                  )
</sxh></p>
<p>== Operador $limit ==</p>
<p>La funci√≥n $limit toma un n√∫mero N y devuelve los primeros N documentos resultantes. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}},
                   {$limit:3}
                  )
</sxh></p>
<p>== Operador $skip ==</p>
<p>La funci√≥n $skip toma un n√∫mero N y desecha los primeros N documentos del conjunto de resultados. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio :-1,paginas:1}},
                   {$skip:3}
                  )
</sxh></p>
<p>== operador $unwind. ==</p>
<p>Dentro de una agregaci√≥n podemos utilizar el operador $unwind, se podr√≠a traducir como "aplanar" ya que aplana los datos
de un array convirti√©ndo sus elementos en documentos independientes. Puede ser √∫til para poder acceder al interior de los
elementos de un array cuando estos no son at√≥micos.</p>
<p><sxh php>
db.usuario.aggregate({$project: {comentarios:1}},
                     {$unwind :"$comentarios" }
                    )
</sxh>evueltos les pondremos el valor 1. El campo _id siempre se devuelve. Tambi√©n podemos especificar los campos que no queremos que sean devueltos, en este caso como valor para cada una de esos campos, pondremos cero. El resultado ser√° que se devolver√°n el resto de documentos.
  db.coleccion1.find({ },{ clave3:0, clave4:0 })</p>
<p>=== Operadores de comparaci√≥n ===
MongoDB permite utilizar los siguientes operadores de comparaci√≥n:
  * <strong>$lt</strong> (less than), se corresponde con la condici√≥n &lt; (menor estricto).
  * <strong>$lte</strong> (less than or equal), se corresponde con la condici√≥n &lt;= (menor o igual).
  * <strong>$gt</strong> (greather than), se corresponde con la condici√≥n &gt; (mayor estricto).
  * <strong>$gte</strong> (greather than or equal), se corresponde con la condici√≥n &gt;= (mayor o igual).</p>
<p>clave: { $operador: valor }</p>
<p>As√≠ si por ejemplo queremos recuperar los libros con un precio mayor que 10 lo har√≠amos utilizando el operador $gt sobre el campo precio:
  db.libro.find({"precio":{$gt:10}},{titulo:1,precio:1})</p>
<p>=== Operadores l√≥gicos ===</p>
<p><strong>$in</strong>
  clave: { $in: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave est√© entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$in:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$nin</strong>
  clave: { $nin: [valor1, valor2, valorN] }
Recupera documentos cuyo campo clave NO est√© entre alguno de los valores especificados en el array, esto es, [ valor1, valor2, valorN ].
  db.libro.find({editorial:{$nin:["Debolsillo","Planeta","Gigamesh"]}},{titulo:1,editorial:1})</p>
<p><strong>$or</strong>
  $or: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que est√©n en stock (enstock:false) o que tengan editorial (editorial:null).
  db.libro.find({$or:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$nor</strong>
  $nor: [ {clave1:valor1}, {clave2:valor2}, {claveN:valorN} ]
Con el siguiente find, vamos a recuperar aquellos documentos que no est√©n en stock (enstock:false) o que no tengan editorial (editorial:null).
  db.libro.find({$nor:[{enstock:false},{editorial:null}]},{titulo:1,editorial:1,enstock:1})</p>
<p><strong>$not</strong></p>
<p>$not es lo que se conoce como un metacondicional, que son opeadores que pueden aplicarse por encima de cualquier otro criterio. Su sintaxis es sencilla, solo hay que ponerlo ‚Äúfuera‚Äù de aquello que queremos negar.
  $not: { criterio }
Y as√≠ directamente podemos recuperar por ejemplo, documentos que no tengan 480 paginas.
  db.libro.find( { paginas: {$not: { $eq:480 } } },{titulo:1,paginas:1} )</p>
<p><strong>$exist</strong></p>
<p>El operador $exists se utiliza para comprobar los documentos que tienen informado o no un campo determinado. Su sintaxis es la siguiente:
  clave: { $exists: boolean}
Donde boolean puede ser true o false. En el caso de true devuelve documentos que tienen informado un campo, aunque su valor sea null. Este operador es √∫til porque debido a la ausencia de definici√≥n de esquema de datos de mongo, cada documento de una misma colecci√≥n puede tener los campos que requiera, y al hacer consultas puede que no nos devuelva ciertos documentos bien porque no entra dentro de los valores exigidos, bien porque el campo no est√° definido.
Veamos un ejemplo con dos comandos find donde utilizamos el operador $exists con ambos valores.
  db.libro.find({paginas:{$exists:true}},{paginas:1})</p>
<p><note important><strong>null</strong> tiene un comportamiento un poco extra√±o, ya que hace matching en los siguientes casos:
  * Con valores que almacenan null, por ejemplo ‚Äúy‚Äù : null
  * Con campos que no existen en un documento. Si por ejemplo el documentoA no tiene informado el campo x, una b√∫squeda por { x:null } s√≠ que se encontrar√≠a.</p>
<p></note></p>
<p><strong>Expresiones regulares</strong></p>
<p>MongoDB incluye el trabajo con expresiones regulares de forma nativa.
Ejemplo: Recuperamos los libros del autor Posteguillo, sin preocuparnos por may√∫sculas y min√∫sculas, har√≠amos esta consulta.
  db.libro.find({autor:/posteguillo/i},{titulo:1,autor:1}).pretty()</p>
<p><strong>B√∫squeda de texto</strong></p>
<p>En MongoDB, podemos realizar b√∫squedas de texto usando el √≠ndice de texto y el operador $text. Pasos:</p>
<p>Primero se crea un √≠ndice de texto en los  campos para realizar la b√∫squeda de  texto. </p>
<p>db.books.createIndex({"title":"text"})   //---  Un campo//
  db.books.createIndex({"title":"text","autor":"text"}) //---  Varios campos//</p>
<p>Luego se realiza la busqueda con $text. La expresi√≥n $text tiene la siguiente sintaxis:
  {
    $text:
    {
        $search: <string>,
        $lenguage: <string>, Opcional
        $caseSensitive: <boolean>,Opcional
        $diacriticSensitive: <boolean> Opcional
    }
  }</p>
<p>Ejemplos:</p>
<p>db.books.find({
           $text:{$search:"la",$caseSensitive:true}
           })</p>
<p>db.books.find({
           $text:{$search:"la -Biblia"}    //--- Busca "la" pero no "Biblia"//
          }) </p>
<p>==== Consultas con Arrays ====</p>
<p>Creamos una colecci√≥n para ver los ejemplos
  db.comida.insert({fruta:["manzana","platano","pera"]})</p>
<p>Para buscar documentos que tengan un elemento concreto dentro del array, es tan simple como poner el nombre del array y el valor que queremos encontrar.
  db.comida.findOne({fruta:"pera"})</p>
<p>Podemos utilizar cualquiera de los operadores aprendidos hasta el momento, como por ejemplo $in, para recuperar documentos que tengan alguno de los
valores especificados.
  db.comida.findOne({fruta: { $in:["pera","platano","melocoton"] }})</p>
<p>Si necesita recuperar arrays que contengan m√°s de un elemento, puede utilizar el operador $all, que permite especificar una lista de elementos.
Modificamos la colecci√≥n para ver unos ejemplos
  db.comida.drop()
  db.comida.insert({_id:1, fruta:["manzana","platano","melocoton"]})
  db.comida.insert({_id:2, fruta:["manzana","kiwi","naranja"]})
  db.comida.insert({_id:3, fruta:["cerezas","platano","manzana"]})</p>
<p>Si ahora queremos documentos que tengan los elementos platano y manzana, lo haremos con $all de esta forma.
  db.comida.find({fruta: { $all:["platano","manzana"]}})</p>
<p>Para recuperar documentos que tengan un valor concreto en cierto √≠ndice delarray, se consigue poniendo dicho √≠ndice (empezando desde cero) tras un punto
del array. Es decir: fruta.0 es el primer elemento del array.
  db.comida.find({"fruta.0":"cerezas"})</p>
<p><strong>$size</strong></p>
<p>Un condicional √∫til para las consultas contra arrays es $size, que permite recuperar arrays que tienen un determinado tama√±o.
La siguiente consulta muestra los documentos que tenga 2 frutas.
  db.comida.find({fruta:{$size:2}})</p>
<p><strong>$slice</strong></p>
<p>El operador $slice se utiliza para devolver un subconjunto de los elementos delarray. No influye en el criterio de b√∫squeda, solo es para especificar a mongo lo
que queremos que nos devuelva. Su sintaxis es la siguiente.
  clave: { $slice: x}
Donde seg√∫n x:
  * x es un entero positivo (p.ej 10), devuelve los primeros x elementos del array clave.
  * x es un entero negativo (p.ej -10), devuelve los √∫ltimos x elementos del array clave.
  * x es un array (p.ej [2,4], devuelve los elementos desde el 2 al 4, ambos incluidos.</p>
<p>Ejemplos:
  db.comida.find({},{fruta:{$slice:2}})
  db.comida.find({},{fruta:{$slice:-2}})
  db.comida.find({},{fruta:{$slice:[1,3]}})</p>
<p><strong>Conjuntos de valores</strong></p>
<p>Si queremos obtener todos los diferentes valores que existen en un campo, utilizaremos el m√©todo distinct
  db.grades.distinct('type')</p>
<p><strong>Contar valores</strong></p>
<p>Para contar el n√∫mero de documentos, en vez de find usaremos el m√©todo count. Por ejemplo:
  db.grades.count({type:"exam"})
  db.grades.find({type:"exam"}).count() 
  db.grades.count({type:"essay", score:{$gt:90}})
==== Documentos embebidos ====</p>
<p>Para hacer queries contra campos de documentos embebidos dentro de otros documentos, solamente hay que poner la ‚Äúruta‚Äù completa de claves separada por puntos. Es decir, si tenemos por ejemplo una estructura como esta para los libros.
  db.libro.save({
          "_id":"9788408117117",
          "titulo":"Circo M√°ximo",
          "autor": {
                    nombre:"Santiago",
                    apellidos:"Posteguillo G√≥mez",
                    nacimiento: {
                                 anyo:1967,
                                 ciudad:"Valencia"
                   }
          },
         "editorial":"Planeta",
         "enstock":true,
         "paginas":1100,
         "precio":21.75
  })</p>
<p>Podemos lanzar queries directamente contra los documentos embebidos, autor y nacimiento de esta forma. Para re
  db.libro.findOne({"autor.nombre":"Santiago"})</p>
<p>El find anterior recuperar√° el primer documento donde el campo nombre, del campo autor sea ‚ÄúSantiago‚Äù.</p>
<p>db.libro.findOne({"autor.nacimiento.anyo":{$gt:1965}})
El find anterior recuperar√° el primer documento donde el campo anyo, del campo nacimiento, del campo autor sea mayor que 1965.
==== Cursores ====
La base de datos devuelve resultados para find utilizando cursores, que realmente es un puntero a los resultados de una query, no los resultados en si
mismos. Los clientes integrados con Mongo, iteran sobre los cursores para recuperar los resultados, y ofrecen un conjunto de funcionalidades como limitar
el n√∫mero de resultados, saltar para no tener que recuperar obligatoriamente los primeros, ordenarlos, etc.</p>
<p>Las opciones de query m√°s comunes son limitar el n√∫mero de resultados, saltar un n√∫mero de resultados, y ordenarlos. Todas estas opciones deben especificarse en la propia query al sistema.</p>
<p>Para fijar un l√≠mite, debe concatenar la funci√≥n <strong>limit</strong> tras la funci√≥n find. Por ejemplo, para solo recuperar los primeros tres libros almacenados, use esto:
  db.libro.find({},{titulo:1}).limit(3)</p>
<p>La funci√≥n <strong>skip</strong> para ‚Äúsaltar‚Äù algunos resultados, funciona de forma similar a limit, concaten√°ndola tras find. Con el siguiente skip(3) saltamos los primeros
tres t√≠tulos, y el cursor empezar√° a devolver a partir del cuarto.
 db.libro.find({},{titulo:1}).skip(3)</p>
<p>La funci√≥n <strong>sort</strong> sirve para ordenar los resultados que se devuelven. Recibe un objeto json con las claves y un valor 1 (para ordenaci√≥n ascendente) o -1 (para ordenaci√≥n descendente).
  db.libro.find({},{titulo:1,precio:1,paginas:1}).sort({precio:1,paginas:-1})</p>
<p>Estas tres funciones, limit, skip y sort, pueden combinarse como se quiera para recuperar exactamente lo que queramos.
  db.libro.find({},{titulo:1,precio:1,paginas:1}).limit(3).skip(2).sort({precio:1, paginas:-1}).pretty()</p>
<p>==== Agregaci√≥n ====
Una vez tenemos datos almacenados en MongoDB, queremos hacer m√°s que solamente recuperarlos, queremos analizarlos de diversas formas interesantes. 
Esto lo conseguimos con la funci√≥n de agregaci√≥n que Mongo ofrece.
La agregaci√≥n nos permite transformar y combinar documentos en una colecci√≥n. B√°sicamente, se construye un pipeline (secuencia de comandos) 
que procesan un conjunto de documentos a trav√©s de varios ‚Äúbloques‚Äù: filtrado, proyecciones, agrupaciones, ordenaci√≥n, limitaci√≥n y skipping.</p>
<p>Por ejemplo, si de la colecci√≥n de libros de ejemplo quisi√©ramos saber los tres autores con m√°s libros escritos, crear√≠amos un pipeline con los siguientes pasos:
  * Proyectar√≠amos el autor de cada libro.0
  * Agrupar√≠amos los autores por nombre, contando el n√∫mero de ocurrencias.
  * Ordenar√≠amos los autores por dicho n√∫mero de ocurrencias, descendentemente.
  * Limitar√≠amos el resultado a los primeros tres.</p>
<p>Cada uno de estos pasos se corresponde con un operador de agregaci√≥n</p>
<ol>
<li>
<p>{‚Äú<strong>$project‚Äù : { ‚Äúautor‚Äù : 1 }}</strong> Esto ‚Äúproyecta/extrae‚Äù el autor de cada documento. La sintaxis es similar al selector  de  campos  utilizado  con  find  (el  segundo  par√°metro), 
especificando  ‚Äúnombrecampo‚Äù:  1  para  incluir  o  ‚Äúnombrecampo‚Äù:0  para excluir.
Despu√©s de esta operaci√≥n, cada documento de los  resultados es algo as√≠: 
{‚Äú_id‚Äù:id,  ‚Äúautor‚Äù:‚Äùnombre  de  autor‚Äù}.  Estos  resultados  solo  existen  en memoria, no se escribir√°n nunca a disco</p>
</li>
<li>
<p __id_:_nombre="‚Äú_id‚Äù:‚Äùnombre" _count_:="‚Äúcount‚Äù:" autor_="autor‚Äù," de="de" numeroDeLibros="numeroDeLibros"><strong>{‚Äú$group‚Äù : { ‚Äú_id‚Äù:‚Äù$autor‚Äù, ‚Äúcount‚Äù: {‚Äú$sum‚Äù:1}}}</strong>  Eso agrupa por autores e incrementa ‚Äúcount‚Äù para cada documento en los que el autor aparece.
Primero especificamos el campo por el que queremos agrupar, que es ‚Äúautor‚Äù. Esto lo indicamos con el ‚Äú_id‚Äù:‚Äù$autor‚Äù. Podr√≠amos entenderlo 
como: tras el Group habr√° un documento resultado para cada autor, por lo que ‚Äúautor‚Äù se convertir√° en el identificador √∫nico (‚Äú_id‚Äù).
El segundo campo significa a√±adir 1 al campo ‚Äúcount‚Äù para cada documento en el grupo. F√≠jese  que los documentos de entrada (libro) no tienen el 
campo ‚Äúcount‚Äù, es un nuevo campo creado por el ‚Äú$group‚Äù.
Al final de este paso, cada documento resultado es algo como: </p>
</li>
<li>
<p><strong>{‚Äú$sort‚Äù : {‚Äúcount‚Äù : -1}}</strong> Esto reordena los resultados por el valor del campo ‚Äúcount‚Äù 
descendentemente (-1). En caso de ascendente ser√≠a ‚Äúcount‚Äù:1.</p>
</li>
<li>
<p><strong>{‚Äú$limit‚Äù : 3}</strong>  Limita el n√∫mero de resultados a los primeros tres.</p>
</li>
</ol>
<p>Veamos todo esto con m√°s detalle y partiendo de un ejemplo con una colecci√≥n de libros</p>
<p 1="1" :=":" Casanovas_="Casanovas&quot;," _Anna="&quot;Anna" __id_="&quot;_id&quot;" _count_="&quot;count&quot;"><sxh php>
db.libro.aggregate({$project:{autor:1}},
                   {$group:{_id:"$autor",count:{$sum:1}}},
                   {$sort:{count:-1}},{$limit:3}
                  )
</sxh>
  { "_id" : "Santiago Posteguillo", "count" : 3 }
  { "_id" : "George R.R. Martin", "count" : 2 }</p>
<p>=== Operaciones Pipeline ===
Cada operador recibe un conjunto de documentos, hace alg√∫n tipo de transformaci√≥n sobre ellos, y despu√©s pasa el resultado de la transformaci√≥n. 
Esto es lo que se conoce como pipeline.</p>
<p>{{ :clase:iabd:bda:mongodb.png?600 |}}</p>
<p>== Operador $match ==</p>
<p>El operador $match filtra documentos de forma que podamos ejecutar una agregaci√≥n sobre un subconjunto de documentos.
$match puede utilizar todos los operadores para query estudiados ($gt, $lt, $in, etc).
Con el siguiente ejemplo, filtrar√≠amos solo aquellos libros con un precio mayor que 20, reduciendo el conjunto inicial de documentos y formando la entrada de 
los siguientes pasos del pipeline.
<sxh php>db.libro.aggregate({$match:{precio:{$gt:20}}})</sxh></p>
<p>Como hemos comentado, cualquiera de las condiciones estudiadas del find podemos utilizarlas con match. Como por ejemplo, los libros en stock. 
<sxh php>db.libro.aggregate({$match:{enstock:true}}) </sxh></p>
<p>== Operador $project ==
La ‚Äúproyecci√≥n‚Äù es mucho m√°s potente en el pipeline que en el lenguaje ‚Äúnormal‚Äù  de la query. $project nos permite extraer campos de subdocumentos, renombrar  campos, y realizar operaciones interesantes sobre ellos. 
La operaci√≥n m√°s sencilla de $project realiza una selecci√≥n simple de unos documentos de entrada, es decir, de los documentos de entrada con campos a, b, c y d, con $project decimos que nos quedamos √∫nicamente con a y c. Para incluir o excluir un campo, se utiliza la misma sintaxis que para el segundo argumento de una query, es decir ‚Äúnombrecampo‚Äù: 1 para incluir o ‚Äúnombrecampo‚Äù:0 para excluir. Por defecto, el campo ‚Äú_id‚Äù siempre se devuelve si existe en los documentos de entrada. Lo podemos eliminar por ejemplo utilizando $project de la siguiente forma, en la que devolver√≠amos todos los campos excepto ‚Äú_id‚Äù. {$project:{ ‚Äú_id‚Äù:0 }}  Con $project tambi√©n podemos renombrar el campo proyectado. </p>
<p>Por ejemplo si queremos devolver el campo ‚Äú_id‚Äù de los libros como ‚Äúisbn‚Äù har√≠amos esto. 
<sxh sql>
db.libro.aggregate({$project:{isbn:"$_id"}})
</sxh></p>
<p>La clave est√° en $_id, cuando ponemos el s√≠mbolo del d√≥lar ($) m√°s el nombre de un campo, nos estamos refiriendo al valor que tomar√° dicho campo para cada documento en el entorno de agregaci√≥n. Por tanto con $project: {‚Äúisbn‚Äù:‚Äù$_id‚Äù} estamos diciendo que proyectamos un nuevo campo isbn como el valor que tendr√° el campo _id en cada documento de entrada. 
Igualmente podr√≠amos haber renombrado cualquier otro campo, por ejemplo el campo ‚Äúenstock‚Äù como ‚Äúdisponible‚Äù. 
<sxh php>db.libro.aggregate({$project:{isbn:"$_id",disponible:"$enstock"}})</sxh></p>
<p>== Expresiones en el Pipeline ==</p>
<p>La operaciones m√°s simples en $project son inclusi√≥n, exclusi√≥n y nombres de campo (‚Äú$nombrecampo‚Äù).<br />
Aunque hay otras m√°s, mucho m√°s potentes. Podemos utilizar expresiones, que nos permiten combinar m√∫ltiples literales y variables en un valor √∫nico. </p>
<p><strong>Expresiones matem√°ticas</strong>. </p>
<p>Las expresiones matem√°ticas nos permiten manipular valores num√©ricos contra los que operar, y que normalmente se especifican en un array. </p>
<p>Esta es la sintaxis para cada operador matem√°tico. 
  * ‚Äú$add‚Äù: [ expr1, expr2, ... , exprN ]. Toma uno o mas expresiones y las suma. 
  * ‚Äú$substract‚Äù: [ expr1, expr2 ]. Resta la expr2 a la expr1. 
  * ‚Äú$multiply‚Äù: [ expr1, expr2, ..., exp√≥n ]. Toma una o m√°s expresiones y las multiplica. 
  * ‚Äú$divide‚Äù: [ expr1, expr2 ]. Divide la expr1 entre la expr2. 
  * ‚Äú$mod‚Äù: [ expr1, expr2 ]. Divide la expr1 entre la expr2 y devuelve el resto. </p>
<p><strong>Expresiones de fechas</strong>. </p>
<p>Muchas agregaciones son basadas en el tiempo. ¬øQu√© ocurri√≥ la semana pasada? ¬øY el mes pasado?. Es por esto que el entorno de agregaci√≥n  tiene  un  conjunto  de  expresiones  que  pueden  utilizarse  para  extraer informaci√≥n sobre fechas de una forma muy usable, son: ‚Äú$year‚Äù, ‚Äú$month‚Äù,‚Äú$week‚Äù, ‚Äú$dayOfMonth‚Äù, ‚Äú$dayOfWeek‚Äù, ‚Äú$dayOfYear‚Äù, ‚Äú$hour‚Äù, ‚Äú$minute‚Äù y ‚Äú$second‚Äù. </p>
<p>Con siguiente sentencia de agregaci√≥n vamos a recuperar tanto la fecha, como el a√±o de dicha fecha, gracias a la expresi√≥n ‚Äú$year‚Äù.</p>
<p><sxh php>db.libro.aggregate({$project:{fecha:1,year:{$year:"$fecha* }}})</sxh></p>
<p><strong>Expresiones de Strings</strong>.</p>
<p>Hay una pocas operaciones b√°sicas sobre cadenas de caracteres que tambi√©n podemos utilizar. Son 
estas: </p>
<p>‚Äú$substr‚Äù: [ expr, start, length ]. Devuelve el substring de la expresi√≥n expr, empezando en la posici√≥n start de la cadena y devolviendo desde ah√≠ un total de length caracteres. En el siguiente ejemplo proyectamos un campo inicio los primeros quince caracteres del campo t√≠tulo.<br />
<sxh php>db.libro.aggregate({$project: {inicio:{$substr: ["$titulo",0,15] }}})</sxh></p>
<p>‚Äú$concat‚Äù: [ expr1, expr2, ..., exprN ]. Devuelve un nuevo string resultado de la concatenaci√≥n de expr1, expr2 y as√≠ hasta exprN. En el siguiente ejemplo proyectamos un campo descripci√≥n en el que concatenamos el titulo, un gui√≥n, y el autor.<br />
<sxh php>db.libro.aggregate({$project:{descripcion:{$concat:["$titulo"," - ","$autor"]},_id:0}})</sxh></p>
<p>‚Äú$toLower‚Äù: expr. Devuelve un string en min√∫sculas. 
‚Äú$toUpper‚Äù: expr. Devuelve un string en may√∫sculas. </p>
<p><strong>Expresiones l√≥gicas</strong>.</p>
<p>Existen algunas operaciones l√≥gicas que podemos utilizar. Replanteamos el ejemplo anterior de la proyecci√≥n del campo ‚Äúbarato‚Äù utilizando  uno de estos comparadores.  </p>
<p><sxh php>db.libro.aggregate({$project:{barato:{$gt:[15,"$precio"]},precio:1} })</sxh></p>
<p>== Operador $sort ==
Podemos ordenar por cualquier campo o conjunto de campos utilizando la misma sintaxis que para las queries ‚Äúnormales‚Äù. Si tenemos que ordenar un n√∫mero de documentos muy elevado, es recomendable desde el punto de vista del rendimiento, que hagamos la ordenaci√≥n al principio del pipeline y adem√°s tengamos un √≠ndice por el conjunto de campos por los que ordenar. De otra forma, $sort puede ser lento y consumir mucha memoria. 
Se pueden utilizar tanto campos existentes como campos proyectados para ordenar. De esta forma podemos por ejemplo completar la agregraci√≥n en la que calcul√°bamos la media aritm√©tica del precio de los libros por autor, y ordenar los resultados por dicha media calculada ascendentemente. </p>
<p><sxh php>
db.libro.aggregate({$group:{_id:"$autor", media:{$avg:"$precio"}}},
                   {$sort:{media:1}}
                  )
</sxh></p>
<p>Para ordenar cada campo es valor 1, para ordenaci√≥n ascendente y -¬≠‚Äê1 para descendente. En el siguiente ejemplo ordenamos primero por precio descendente y despu√©s por p√°ginas ascendente.
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}}
                  )
</sxh></p>
<p>== Operador $limit ==</p>
<p>La funci√≥n $limit toma un n√∫mero N y devuelve los primeros N documentos resultantes. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio:-1,paginas:1}},
                   {$limit:3}
                  )
</sxh></p>
<p>== Operador $skip ==</p>
<p>La funci√≥n $skip toma un n√∫mero N y desecha los primeros N documentos del conjunto de resultados. 
<sxh php>
db.libro.aggregate({$project:{precio:1,paginas:1}},
                   {$sort:{precio :-1,paginas:1}},
                   {$skip:3}
                  )
</sxh></p>
<p>== operador $unwind. ==</p>
<p>Dentro de una agregaci√≥n podemos utilizar el operador $unwind, se podr√≠a traducir como "aplanar" ya que aplana los datos
de un array convirti√©ndo sus elementos en documentos independientes. Puede ser √∫til para poder acceder al interior de los
elementos de un array cuando estos no son at√≥micos.</p>
<p><sxh php>
db.usuario.aggregate({$project: {comentarios:1}},
                     {$unwind :"$comentarios" }
                    )
</sxh></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy"], "search": "../../../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.dff1b7c8.min.js"></script>
      
    
  </body>
</html>